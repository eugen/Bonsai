\documentclass[12pt,a4paper]{memoir}
\usepackage[romanian]{babel}
\usepackage[dvipsnames]{color}
\usepackage{fancyvrb,fontspec,xunicode,xltxtra,hyperref,url,framed,verbatim}

% stop breaking words into syllables too agressively
\hyphenpenalty=5000
\tolerance=1000

% nicer fonts
\setmainfont{Calluna}
\setmonofont{Inconsolata}

\definecolor{shadecolor}{named}{Gray}

% title of the PDF document and link colors
\hypersetup{pdftitle={Bonsai - Un limbaj dinamic funcțional peste DLR},citebordercolor={0.8 0 0},filebordercolor={0.8 0 0},linkbordercolor={0.8 0 0},menubordercolor={0.8 0 0},urlbordercolor={0.8 0 0},runbordercolor={0.8 0 0}}

% include subsections in the TOC
\setcounter{tocdepth}{4}

\newcommand{\draft}{\textcolor{red}}

% footnotes with symbols instead of numbers
\renewcommand{\thefootnote}{\fnsymbol{footnote}}

% we don't use cedillas, so just redifine \c as \texttt
% this is probably not ``politically correct''
\renewcommand{\c}{\texttt}

% define a new environment for code; shading is nice;
\newenvironment{code}
{
\definecolor{shadecolor}{gray}{0.91}
\topsep=0ex
\relax
\shaded
\verbatim
}
{
\endverbatim
\endshaded
}


\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Header
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}
\vspace*{-4cm}
\begin{centering}
\textbf{\textsc{\Large{Universitatea Alexandru Ioan Cuza Iași\\Facultatea de Informatică}}}

\vspace{7cm}

\textbf{\HUGE{Bonsai}\\[0.5cm]
\LARGE{Un limbaj dinamic funcțional peste DLR}}
\\[3cm]

\flushleft
\begin{minipage}{0.4\linewidth}
\centering
\large
\emph{Autor:}\\
Eugen \textsc{Anghel}
\end{minipage}
\hspace{0.5cm}
\flushright
\vspace{-1.5cm}
\begin{minipage}{0.5\linewidth}
\centering
\large
\emph{Coordonator Științific:} \\
Prof. Dr. Gheorghe \textsc{Grigoraș}
\end{minipage}
\vfill
\centering\large{\textsc{Februarie 2010}}\\
\end{centering}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Declarațiile
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\thispagestyle{empty}
\begin{centering}
\LARGE{\textbf{Declaraţie privind originalitate şi respectarea drepturilor de autor}}
\end{centering}

\vspace{2cm}

Prin prezenta declar că Lucrarea de licență cu titlul „Bonsai - Un limbaj dinamic funcțional peste DLR” este scrisă de mine și nu a mai fost prezentată niciodată la o altă facultate sau instituție de învățământ superior din țară sau străinătate. De asemenea, declar că toate sursele utilizate, inclusiv cele preluate de pe Internet, sunt indicate în lucrare, cu respectarea regulilor de evitare a plagiatului
\begin{itemize}
\item toate fragmentele de text reproduse exact, chiar și în traducere proprie din altă limbă, sunt scrise între ghilimele şi dețin referința precisă a sursei;
\item reformularea în cuvinte proprii a textelor scrise de către alți autori deține referința precisă;
\item codul sursă, imagini etc. preluate din proiecte \emph{open-source} sau alte surse sunt utilizate cu respectarea drepturilor de autor şi dețin referințe precise;
\item rezumarea ideilor altor autori precizează referința precisă la textul original.
\end{itemize}
\vspace{2cm}
Iași, 19 februarie 2010
\\[1cm]
\begin{flushright}
Absolvent \emph{Eugen \textsc{Anghel}}\\[1.4cm]
\rule{0.31\linewidth}{0.2mm}
\end{flushright}

\cleardoublepage
\thispagestyle{empty}
\begin{centering}
\LARGE{\textbf{Declaraţie de consimțământ}}
\end{centering}

\vspace{2cm}

Prin prezenta declar că sunt de acord ca Lucrarea de licență cu titlul „Bonsai - Un limbaj dinamic funcțional peste DLR”, codul sursă al programelor și celelalte conținuturi (grafice, multimedia, date de test etc.) care însoțesc această lucrare să fie utilizate în cadrul Facultății de Informatică. De asemenea, sunt de acord ca Facultatea de Informatică de la Universitatea Alexandru Ioan Cuza Iași să utilizeze, modifice, reproducă și să distribuie în scopuri necomerciale programele-calculator, format executabil și sursă, realizate de mine în cadrul prezentei lucrări de licență.
\\[2cm]
Iași, 19 februarie 2010
\\[1cm]
\begin{flushright}
Absolvent \emph{Eugen \textsc{Anghel}}\\[1.4cm]
\rule{0.31\linewidth}{0.2mm}
\end{flushright}
\cleardoublepage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Cuprins
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{page}{1}
\tableofcontents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introducere}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

În ultimele doua decenii, programarea a fost în mare parte împărțită între două grupe de limbaje. Limbajele imperative, cu un sistem static de tipuri, multe dintre ele din familia C, au fost folosite pentru a obține performanță și scalabilitate. În schimb, flexibilitatea limbajelor precum Perl si PHP a fost apreciată pentru programarea scripturilor de sistem, a paginilor web și a altor programe pentru care eficiența nu reprezintă o prioritate.

În ultimii ani însă, odată cu reducerea exponențială a costurilor hardware-ului — mulțumită legii lui Moore — accentul a început să se pună din ce în ce mai puțin pe eficiență și din ce în ce mai mult pe timpul de dezvoltare. Performanța limbajelor dinamice a devenit „suficientă”, ceea ce a condus la o adevărată renaștere a acestora.

Atât Sun cât și Microsoft și-au arătat interesul pentru limbajele dinamice prin proiectele The Da Vinci Machine\cite{daVinciMachine} și Dynamic Language Runtime (DLR)\cite{dlr} și sprijinirea dezvoltării limbajelor JRuby\cite{jruby}, Jython\cite{jython}, IronRuby\cite{ironruby}, IronPython\cite{ironpython}, etc.

Lucrarea de față prezintă un limbaj dinamic numit Bonsai. Cea mai importantă caracteristică a sa este simplitatea, limbajele Lisp, Javascript și Io\cite{io} reprezentând principalele surse de inspirație.

Platforma aleasă este .NET Framework, împreună cu Dynamic Language Runtime. Întreaga suită de biblioteci .NET este astfel disponibilă, indiferent de limbajul in care au fost ele scrise. 

Bonsai este un limbaj funcțional\footnote{Datorită utilizării bibliotecilor .NET, transparența referențială a funcțiilor nu poate fi garantată. Bonsai nu este, așadar, un limbaj pur funcțional.}, dar se integrează bine cu alte limbaje orientate obiect, OOP-ul fiind simulat în întregime prin apeluri de funcții. Bonsai implementează de asemenea o formă de programare bazată pe prototipuri, inspirată din JavaScript.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Parsarea și generarea arborilor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Primul modul din componența Bonsai se numește \c{Bonsai.Parser} și se ocupă de parsarea codului sursă și generarea arborilor de sintaxă abstractă.

\section{Scurtă descriere a ANTLR}

ANTLR 3\cite{antlr} este un instrument pentru construcția compilatoarelor și a translatoarelor care utilizează algoritmul de parsare \c{LL(*)} cu predicate\cite{definitive_antlr_reference}. Comparat cu ANTLR 2 (care bazat pe algoritmul \c{LL(k)}), numărul de gramatici care pot fi parsate este cu mult îmbunătățit. Parserele generate sunt descendente-recursive, iar lista de limbaje suportate\cite{antlr_targets} include C, C\#, Java, Python și Javascript. 

În plus, spre deosebire de majoritatea generatoarelor de parser, ANTLR oferă în afară de suportul pentru scrierea de acțiuni asociate fiecărei reguli și opțiunea de a returna direct o instanță a unui arbore de parsare. Modul în care un nod este creat în urma aplicării unei reguli de gramatică poate fi controlat printr-o serie de operatori\cite[cap. 7]{definitive_antlr_reference}.

Începând cu versiunea 3.1, ANTLR oferă și posibilitatea de a efectua transformări arbitrare și succesive asupra arborilor: spre exemplu, pornind de la arborele de parsare, mai multe gramatici de arbori (tree grammars) pot fi înlănțuite pentru a obține un arbore de sintaxă abstractă cât mai convenabil sau pentru aplicarea a diverse optimizări\cite{antlr_tree_grammars}\cite[cap. 8]{definitive_antlr_reference}.

Bonsai utilizează ANTLR 3.1 pentru parsarea codului sursă și pentru generarea AST-ului din arborele de parsare.

\section{Parsarea codului sursă}

Simplitatea limbajului se reflectă în dimensiunile gramaticii: aceasta are doar 18 reguli de parsare (inclusiv lexerul) și nici un cuvânt nu este rezervat\footnote{Gramatica de parsare este listată în întregime în Anexa \ref{app:grammar}}. În urma aplicării unei reguli rezultă un arbore de parsare, generat conform instrucțiunilor din gramatică. Acesta conține încă un număr ridicat de artefacte și nu poate fi considerat un arbore de sintaxă abstractă.

Din gramatică au fost generate cu ANTLR clasele \c{BonsaiParser} și \c{BonsaiLexer}. Următorul fragment oferă un exemplu de utilizare:

\begin{code}
var text = "... Bonsai code ...";
var strStream = new ANTLRStringStream(text);
var lexer = new BonsaiLexer(strStream);
var tokStream = new CommonTokenStream(lexer);
var parser = new Generated.BonsaiParser(tokStream);
var returnValue = parser.program();
\end{code}

Metoda \c{program} semnifică aplicarea regulei cu același nume. După rulare, \c{returnValue.Tree} va conține arborele de parsare.

\section{Generarea AST-ului}

Pe lângă gramatica de parsare, Bonsai utilizează și o gramatica de arbori, de doar 3 reguli\footnote{Gramatica de arbori este listată în întregime în Anexa \ref{app:tree_grammar}}, care transformă arborele de parsare într-un arbore de sintaxă abstractă. Clasa generată din aceastra gramatică este \c{BonsaiTree}.

Fragmentul următor este continuarea codului din secțiunea precedentă și demonstrează aplicarea gramaticii de arbori pe rezultatele parsării:

\begin{code}
var tree = (CommonTree)returnValue.Tree;
var treeNodeStream = 
    new CommonTreeNodeStream((CommonTree)returnValue.Tree);
var treeWalker = new Generated.BonsaiTree(treeNodeStream);
List<Call> statements = treeWalker.program().result.Statements;
\end{code}

După rulare, variabila \c{statements} va conține o listă de instanțe ale clasei \c{Call}. Este important de observat că rezultatul aplicării gramaticii de arbori reprezintă chiar instanțe de clase din namespace-ul \c{Bonsai.Ast}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introducere în DLR}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Dynamic Language Runtime\cite{dlr} este un framework open-source dezvoltat de Microsoft cu scopul de a simplifica și uniformiza implementarea limbajelor dinamice pe platforma .NET. DLR oferă API-uri pentru:
\begin{itemize}
\item Rezolvarea într-un mod standard a apelurilor dinamice la rulare
\item Caching-ul expresiilor Linq compilate
\item Găzduirea unui program dinamic în înteriorul unui proces .NET obișnuit (Hosting API)
\end{itemize}

\section{CallSites}

Un \c{CallSite} reprezinta un context în care sunt rezolvate call-uri dinamice. Acesta poate fi asociat cu o singură linie de cod care conține un apel către o instanță a tipului \c{dynamic} din C\# 4.0\cite{csharp_4_specs} sau cu un întreg program scris într-un limbaj dynamic. 

Scopul principal al \c{CallSite}-urilor este de a mări performanța apelurilor dinamice prin păstrarea rezultatelor anterioare într-un cache. Când este nevoie de rezolvarea unui call, \c{CallSite}-ul caută mai întâi în cache un rezultat potrivit (prin testarea \c{BindingRestrictions}-urilor) și, dacă acesta este găsit, îl returnează imediat. Dacă nu (în cazul unui cache-miss), cererea este înaintată către un \c{Binder}.

\section{DynamicMetaObject, Binders și BindingRestrictions}

Un rezultat al rezolvării unui apel dinamic este reprezentat de o instanță a clasei \c{DynamicMetaObject}\cite{dynamic_meta_object}. Aceasta conține expresia LINQ\cite{linq_expressions} a apelului, tipul de date așteptat, valoarea la rulare a apelului (unde este cazul) și un set de \c{BindingRestrictions} care exprimă condițiile în care rezultatul este valid.

Un \c{Binder} este o clasă responsabilă cu rezolvarea unuia sau mai multe tipuri de expresii dinamice, cum ar fi apeluri de funcții, apeluri de membri, operatori infix, etc și returnarea unei instanțe de \c{DynamicMetaObject} ca rezultat. Binder-ele sunt specifice unui anumit limbaj, rolul lor fiind de a ajuta la implementarea semanticii acestuia.

Pentru a rezolva apelurilor dinamice, un \c{Binder} trebuie să genereze o expresie LINQ asociată rezultatului și să returneze un \c{DynamicMetaObject} format din această expresie împreună cu un set de \c{BindingRestrictions}.

\section{Arbori de expresii}

Expresiile LINQ au fost introduse prima dată în versiunea 3.5 a .NET Framework\cite{expression_trees_35} și permit reprezentarea type-safe a anumitor „expresii” de cod managed, cum ar fi apelul unei metode sau o operație binară precum \c{a + 3}, într-un mod independent de limbaj. Expresiile sunt înstanțe de clase care moștenesc \c{System.Linq.Expressions.Expression}.

Fragmentul următor de cod oferă un scurt exemplu de utilizare, mai precis generarea și compilarea la runtime a unei expresii lambda care primește un parametru \c{a} de tip \c{int} și întoarce valoarea sa incrementată cu \c{1} (\c{a + 1}).
\begin{code}
// parametrul expresiei lambda declarate mai jos
var param = Expression.Parameter(typeof(int), "a");
var expr =
  Expression.Lambda<Func<int, int>>(
    // body-ul
    Expression.Add(
      param, //referintă la parametrul "a"
      Expression.Constant(1)),
    //lista de parametri
    new Expression[] { param });
// expresia LINQ se compilează într-un Func<int, int>
Func<int, int> func = expr.Compile();
Debug.Assert(10 == func(9));
\end{code}

Atât C\# 3.0 cât și VisualBasic 9.0 (versiunile din .NET 3.5) suportă definirea expresiilor LINQ într-un mod mult mai simplu. Toate expresiile asignate unei variabile de tipul \c{Expression<TDelegate>} sunt procesate de compilator și înlocuite cu instanțe de expresii lambda care pot fi compilate sau analizate la runtime:
\begin{code}
Expression<Func<int, int>> expr2 = a => a + 1;
Func<int, int> func2 = expr2.Compile();
Debug.Assert(10 == func2(9));
\end{code}
În exemplul de mai sus, funcția \c{x => x + 1} este procesată de compilatorul C\# 3.0 iar variabilei \c{expr2} îi este asignată o expresie echivalentă celei din primul exemplu.

Expresiile LINQ pot fi de asemenea descompuse, analizate sau combinate cu alte expresii. Linq2Sql se folosește de această funcționalitate pentru a genera cod SQL plecând de la expresii C\# sau VB9.

\section{IDynamicMetaObjectProvider}\label{sec:IDynamicMetaObjectProvider}

Pe lângă Bindere, DLR-ul oferă și posibilitatea ca un obiect să rezolve singur apelurile dinamice asupra lui, precum invocarea ca funcție sau apelul unui membru. Pentru aceasta, el trebuie să implementeze interfața \\ \c{IDynamicMetaObjectProvider}\cite{i_dynamic_meta_object_provider}. Binder-ele pot scurtcircuita acest mecanism și returna propriul rezultat, dar recomandat este ca rezolvarea unui apel către un obiect care implementează \c{IDynamicMetaObjectProvider} să fie prelucrată de acesta, și nu de Binder.

Acest mecanism este deosebit de important pentru interoperabilitatea între limbaje dinamice diferite. De exemplu, un Binder din IronPython ar trebui să lase un obiect IronRuby să rezolve apelurile cu semantica proprie, de Ruby, și să nu încerce aplicarea semanticii Python. Astfel, toate obiectele cu semantică Ruby trebuie vor implementa interfața \c{IDynamicMetaObjectProvider}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Runtime-ul Bonsai}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Al doilea modul Bonsai, pe lângă \c{Bonsai.Parser}, este \c{Bonsai.Runtime}. Acesta include componente responsabile cu executia codului, implementarea semanticii Bonsai, integrarea cu CLR-ul și implementarea componentelor necesare din DLR.

\section{Generarea expresiilor LINQ}

Odată obținut AST-ul după parsare, următorul pas este transformarea acestuia în expresii LINQ\cite{linq_expressions}. 

Clasa răspunzătoare este \c{Bonsai.Runtime.Generator}. Aceasta conține câte o supraîncărcare a metodei \c{Walk} pentru fiecare tip de nod din arborele de sintaxă abstractă. Toate supraîncărcările au o definiție similară și întorc o expresie LINQ:
\begin{code}
public static class BonsaiExpressionGenerator {
  Expression Walk(Expression currentScopeVar, Call call);       
  Expression Walk(Expression currentScopeVar, Number number);
  Expression Walk(Expression currentScopeVar, String str);
  Expression Walk(Expression currentScopeVar, Symbol symbol);
  Expression Walk(Expression currentScopeVar, Block block);
  Expression Walk(Expression currentScopeVar, Reference ref);
  Expression Walk(Expression currentScopeVar, Sequence seq);
  Expression Walk(Expression currentScopeVar, DataDecl decl);
}
\end{code}

\subsection{Tratarea scope-ului}\label{sec:ScopeManagement}

În Bonsai, contextul de execuție curent este format din dicționarul variabilelor definite în contextul curent și o referință la contextul părinte. În momentul accesării unei variabile, ea este căutată mai întâi în dicționarul local, apoi în contextul părinte, recursiv.

Datorita semanticii blocurilor din Bonsai, ca în multe alte limbaje dinamice, contextul în care se execută un bloc nu poate fi cunoscut în momentul compilării. Soluția constă în tratarea acestuia ca pe o variabilă normală cu tipul \c{DictionaryBonsaiFunction}. 

Pentru ca expresiile LINQ generate să poată folosi contextul, toate supraîncărcările metodei \c{Generator.Walk} primesc ca prim parametru o expresie LINQ care reprezintă această variabilă.

De exemplu, mai jos este listată supraîncărcarea metodei \c{Walk} care corespunde unui nod AST de tipul \c{Reference}. Nodurile \c{Reference} semnifică accesarea unei variabile din context după numele acesteia. 
\begin{code}
public static Expression Walk(
    Expression currentScopeVar,
    Ast.Reference reference)
{
    return Expression.MakeIndex(
        currentScopeVar,
        typeof(DictionaryBonsaiFunction).GetProperty("Item", 
            typeof(BonsaiFunction), new Type[] { typeof(SymbolId) }), 
        new Expression[] { Expression.Constant(
            SymbolTable.StringToId(reference.Name)) });
}
\end{code}
Primul parametru al metodei, \c{currentScopeVar}, este expresia menționată anterior, asociată variabilei în care e stocat contextul, iar expresia returnată reprezintă accesul printr-un indexer la aceasta. Codul C\# echivalent ar fi următorul:
\begin{code}
currentScope[someVariable]
\end{code}

\section{Clasa BonsaiBinder}

Deoarece totul în Bonsai este privit ca un apel de funcție, clasa \c{BonsaiBinder} implementează clasa abstractă \c{InvokeBinder}. Aceasta este o unealtă ajutătoare din DLR, potrivită cazurilor în care un implementator nu este interesat decât de apelurile dinamice care reprezintă invocări de funcții. 

Singura metodă din \c{InvokeBinder} care trebuie supraîncărcată este\\ \c{FallbackInvoke}:
\begin{code}
public override DynamicMetaObject FallbackInvoke(
  DynamicMetaObject target,
  DynamicMetaObject[] args);
\end{code}
Primul parametru reprezintă obiectul apelat, iar al doilea un vector cu argumentele apelului.

Dacă \c{target} implementează interfața \c{IDynamicMetaObjectProvider}, \\\c{InvokeBinder} redirectează rezolvarea apelului către \c{target}. \c{FallbackInvoke} este apelat doar în cazul în care \c{target} nu poate rezolva apelul singur.

\c{BonsaiBinder.FallbackInvoke} testează dacă apelul întră într-una din următoarele categorii:
\begin{enumerate}
\item Apelarea unui \c{Delegate}
\item Referențierea unui obiect CLR
\item Apelarea unei primitive Bonsai
\item Invocarea unui membru al unui obiect CLR
\end{enumerate}

În caz contrar se consideră că binding-ul a eșuat și este aruncată o excepție.

\subsection{Apelarea unui Delegate}

Dacă tipul \c{target}-ului este o subclasă a \c{System.Delegate}, \c{BonsaiBinder} consideră acest apel dinamic ca fiind un apel static al unui delegate, iar Expresia generată va fi de tipul \c{InvocationExpression}.

\subsection{Referențierea obiectelor CLR}

Dacă \c{target} este un obiect CLR obișnuit non-dinamic și lista de argumente este vidă, binder-ul tratează apelul ca pe o „referențiere” și returnează expresia inițială (\c{target.Expression}). În alte cuvinte, un obiect obișnuit se evaluează la el însuși.

\subsection{Apelarea primitivelor și invocarea membrilor obiectelor CLR}

Atât în cazul primitivelor cât si al membrilor obiectelor CLR, apelul va fi rezolvat printr-un call al unei metode dintr-un tip CLR. În cazul primitivelor, o metodă din clasa în care acestea sunt definite (\c{Bonsai.Runtime.Primitives}), în cel al membrilor obiectelor CLR, din clasa obiectului \c{target}. Mai multe detalii vor fi prezentate în secțiunile ce urmează.

\section{Invocarea membrilor obiectelor CLR}\label{sec:invoking_clr_members}

Pentru ca un apel dinamic să poate fi tratat de către binder ca un call static către o metodă sau proprietate CLR, următoarele condiții trebuie să fie îndeplinite:

\begin{enumerate}
\item Lista de argumente să fie non-vidă, iar primul argument să fie de tipul \c{SymbolId}.
\item Tipul obiectului \c{target} să conțină o metodă sau proprietate publică numită similar simbolului din primul argument.
\item Tipul argumentelor din apel (mai puțin primul, simbolul) trebuie să fie compatibile cu parametrii metodei sau proprietății.
\end{enumerate}

Notă: În cazul în care simbolul se termină cu caracterul „\c{=}”, binder-ul consideră apelul curent ca fiind accesarea unui setter. 

Fragmentul de code de mai jos ofera câteva exemple de apelare a metodelor și proprietăților CLR:
\begin{code}
= .list [| 1 2 3 ]
  -> [ 1 2 3 ]
# accesarea getter-ului proprietatii Item (indexerul listei)
list .Item 0
  -> 1
# accesarea getter-ului proprietatii Count
list .Count
  -> 3
# apelarea metodei Add
list .Add 4
  -> [ 1 2 3 4 ]
# apelarea setter-ului proprietatii Item
list .Item= 3 5
  -> [ 1 2 3 5 ]
\end{code}

Notă: binder-ul caută metode și proprietăți atât statice cât și non-statice, ale instanței. 

\section{Tratarea tipurilor de date primitive}\label{ch:runtime_sec:primitives}

Primitivele sunt funcții care extind tipuri CLR. Odata încărcate și asociate cu un tip, primitivele devin „metode virtuale” ale tipului respectiv și pot fi apelate cu aceeași sintaxă ca toate celelalte metode\footnote{Primitivele din Bonsai sunt similare metodelor extensie din C\# 3.0.}.

Motivația introducerii primitivelor reprezintă posibilitatea de a extinde tipuri CLR care nu pot fi înlocuite cu tipuri specifice Bonsai (ex. \c{String}) sau care sunt necesare pentru interoperabilitate cu bibliotecile existente (ex. \c{IList<T>}). Poate cel mai bun exemplu îl constituie numerele: toate operațiile matematice în Bonsai sunt implementate ca primitive ale tipului \c{System.Decimal}.

Capitolul \ref{ch:Primitives} include lista completă a primitivelor definite în Bonsai.

\subsection{Definirea primitivelor}

Toate primitivele sunt metode ale clasei \c{BonsaiPrimitives} decorate cu atributul \c{PrimitiveAttribute}. Acest atribut specifică tipul CLR pe care îl extinde primitiva și numele acesteia. Fragmentul următor definește o primitivă pentru clasa \c{System.String}, numită \c{capitalize}, care transformă prima literă a fiecărui cuvânt în majusculă:
\begin{code}
[Primitive(typeof(string), "capitalize")]
public static string Capitalize(
  string target,
  DictionaryBonsaiFunction scope,
  object[] args)
{
  Debug.Assert(args.Length == 0);
  return Regex.Replace(
    target, @"\b\w",
    new MatchEvaluator(m => m.Value.ToUpperInvariant()));
}
\end{code}

Primitivele pot fi definite și pentru tipuri CLR generice: o primitivă definită pentru tipul generic \c{System.Collections.Generic.List<T>} se va aplica tuturor instanțelor acestui tip. Primitiva \c{shuffle} este un exemplu:
\begin{code}
[Primitive(typeof(IList<>), "shuffle")]
public static IList<T> IListShuffle<T>(
  IList<T> target,
  DictionaryBonsaiFunction scope,
  object[] args)
{
  // create copy
  var copy = new List<T>(target);
  var rng = new Random();
  var n = target.Count;
  // Knuth's shuffle
  for(int i = n - 1; i > 0; i--) {
    int j = rng.Next(0, n);
    var tmp = copy[j];
    copy[j] = copy[i];
    copy[i] = tmp;
  }
  return copy;
}
\end{code}

Metodele ce implementează primitive trebuie să aibă trei parametri (după cum se poate observa și din exemplu):
\begin{description}
\item[target]\hfill\\ obiectul apelat
\item[scope]\hfill\\ contextul apelului
\item[args]\hfill\\ lista de argumente
\end{description}

Parametrul \c{scope} nu este utilizat în mod uzual, dar opțiunea de a accesa și analiza contextul la runtime deschide numeroase posibilități, cum ar fi dezvoltarea unui debugger.

\subsection{Apelul primitivelor}

O primitivă se apelează ca orice altă metodă:
\begin{code}
# apel către o metodă CLR
"abc def ghi" .ToUpper
  -> "ABC DEF GHI"
# apel către o primitivă Bonsai
"abc def ghi" .capitalize
  -> "Abc Def Ghi"
\end{code}

Binderul verifică dacă apelul curent este un apel al unei primitive dupa valoarea primului argument, un simbol care trebuie să conțină numele primitivei, cât și după tipul obiectului apelat (din parametrul \c{target}), al cărui tip trebuie să fie compatibil cu cel specificat în atributul \c{PrimitiveAttribute}.

\section{Clasa BonsaiFunction}

Pe lângă cazurile tratate de \c{BonsaiBinder}, apelurile dinamice pot fi rezolvate direct de obiectele din \c{target}. Așa cum a fost menționat în secțiunea \ref{sec:IDynamicMetaObjectProvider}, acestea trebuie doar să implementeze interfața\\ \c{IDynamicMetaObjectProvider}. Clasa abstractă \c{BonsaiFunction} implementează această interfață și este clasa de bază pentru toate obiectele Bonsai sau, mai bine zis, pentru funcțiile din Bonsai.

O mare parte din semantica Bonsai este implementată în subclase ale \c{BonsaiFunction}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Funcții și tipuri standard}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Capitolul curent prezintă tipurile de date și funcțiile disponibile ca standard în Bonsai și oferă exemple de utilizare pentru fiecare dintre ele.

\section{Simboluri}

Simbolurile sunt probabil cel mai utilizat tip de date în limbajul Bonsai. Ele sunt foarte asemănătare simbolurilor din Ruby\cite{ruby_symbols} și Lisp\cite{clhs_symbols}. Un simbol se comportă de cele mai multe ori ca un string. Diferența majoră constă în faptul că pentru orice string există o singură instanță a unui simbol cu acea valoare, ceea ce face compararea a două simboluri foarte rapidă. De asemenea, utilizarea unui simbol indică de cele mai multe ori folosirea metaprogrămarii.

Din punct de vedere sintactic, simbolurile sunt definite de următoarele reguli de gramatică:
\begin{code}
fragment NAMECHAR
    :   ~(' '|'\t'|'{'|'}'|'('|')'|'['|']'|'\n'|'\r'|'\''|'"')
    ;
SYMBOL
    :   '.' NAMECHAR*
    ;
\end{code}
Fragmentul de mai jos conține câteva exemple de simboluri valide:
\begin{code}
.simbol1
.SIMBOL_2
.42
.+
.=a8a=
.|CASE|
\end{code}

\section{Asignarea variabilelor}

Bonsai dispune de două functii pentru asignarea și declararea variabilelor, \c{=} și \c{=:}. Ambele primesc ca parametri un simbol cu numele variabilei și un obiect cu valoarea acesteia:
\begin{code}
=: .a 5
= .b "abc"
\end{code}

În cazul în care variabila nu este definită în nici un context din lanțul de contexte, ambele funcții se comportă la fel: o nouă variabilă este inserată în contextul curent cu valoarea specificată. 

Dacă variabila este deja definită în contextul curent, ambele funcții vor avea, din nou, același efect și vor suprascrie valoarea veche cu cea nouă.

Diferența apare dacă variabila nu este definită în contextul curent, dar este în schimb definită în altă parte în lanțul de contexte. În acest caz, funcția \c{=} va actualiza cea mai apropiată variabila deja existentă cu noua valoare, pe când funcția \c{=:} va crea o nouă variabilă în contextul curent. 

Fragmentul următor ilustrează această diferență:
\begin{code}
= .a .OuterValue
{ = .a .InnerValue } .Invoke
a
  -> .InnerValue
= .b .OuterValue
{ =: .b .InnerValue } .Invoke
b
  -> .OuterValue
\end{code}
Apelul primului bloc modifică variabila \c{a} definită în contextul exterior, pe când cel de-al doilea definește o nouă variabilă \c{b}, diferită de cea exterioară.

\section{Comparatori}

Bonsai definește următoarele funcții pentru efectuarea comparațiilor între două valori:

\begin{description}
\item[\c{==}]\hfill\\Testarea de egalitate
\item[\c{>}]\hfill\\Operatorul „mai mare”
\item[\c{>=}]\hfill\\Operatorul „mai mare sau egal”
\item[\c{<}]\hfill\\Operatorul „mai mic”
\item[\c{<=}]\hfill\\Operatorul „mai mic sau egal”
\end{description}

Toate acestea pot primi oricâte argumente (dar cel puțin 2); operația de comparare va fi executată pentru toate perechile de argumente consecutive:
\begin{code}
== "1" (1 .ToString)
  -> True
== 1 1 1
  -> True
== 1 1 3
  -> False
< 1 2 3
  -> True
<= 1 2 3 3 4
  -> True
> 3 2 2
  -> False
\end{code}

\section{Blocuri}

Un bloc în Bonsai reprezintă o secvență de instrucțiuni cuprinsă între paranteze acolade. Ca orice alt obiect, un bloc poate fi stocat într-o variabilă, trimis ca argument către alte funcții sau apelat:
\begin{code}
= .a_block { 42 }
print (a_block .Invoke)
  -> 42
\end{code}
Metoda din fragmentul de mai sus, \c{Invoke}, este singura acceptată de blocuri și nu primește nici un parametru. 

\section{Definirea funcțiilor cu \c{defun}}\label{sec:defun}

Funcția \c{defun} este folosită pentru definirea de noi funcții. Parametrii acesteia sunt un simbol ce reprezintă numele funcției, urmat de N simboluri care conțin numele parametrilor, iar la final un bloc care constituie corpul noii funcții:
\begin{code}
# definirea functiei f
defun .f .a .b {
  a .+ b 
}
# apelarea ei
f 2 3
  -> 5
\end{code}
\c{.f} este numele noii funcții iar \c{.a} și \c{.b} numele parametrilor. Blocul \c{\{a .+ b\}} referențiază cei doi parametri, apelând metoda \c{.+} a lui \c{a} cu \c{b} ca argument.

Funcția \c{defun} poate fi apelată de mai multe ori pentru același nume de funcție. Fiecare apel va suprascrie valoarea anterioară din contextul curent.

\section{Pattern-matching cu \c{def|}}

Bonsai suportă și o variantă limitată de pattern-matching. Funcția \c{def|} este similară funcției \c{defun}, cu două diferențe:
prima este că o parte din argumente, în afară de simboluri reprezentând numele parametrilor, pot fi șabloane. Cea de-a doua este că apelările ulterioare cu același nume de funcție nu vor suprascrie funcția în context, ci vor adăuga noi seturi de șabloanele la funcția deja existentă.

Un șablon este o instanță a unei clase care implementează interfața \c{IPattern}:
\begin{code}
public interface IPattern {
  SymbolId ParameterName { get; }
  bool Test(object value);
}
\end{code}
Aceasta conține un symbol care definește numele parametrului din contextul funcției și o metodă \c{Test}, care testează la runtime dacă apelul se potrivește sau nu cu șablonul.

Pentru specificarea șabloanelor există o serie de funcții standard:
\begin{description}
\item[\c{|=}]\hfill\\ Testare de egalitate cu o altă valoare. Tipul șablonului este \c{EqPattern}.
\item[\c{|is}]\hfill\\ Testare a tipului parametrului. Tipul șablonului este \c{IsPattern}.
\item[\c{|>}, \c{|<}, \c{|>=}, \c{|<=}]\hfill\\ Șabloane pentru comparații cu o altă valoare
\end{description}

Alegerea unei variante dintre cele specificate se face la runtime. Variantele sunt verificate, în ordinea definirii, prin testarea șabloanelor peste lista de argumente. Dacă nici una dintre variante nu se potrivește atunci este aruncată o excepție.

Un exemplu clasic de utilizare al pattern-matching-ului este funcția factorial:
\begin{code}
def| .factorial (|= .zero 0) { 1 }
def| .factorial .a { a .* (factorial (a .- 1)) }
\end{code}
Fragmentul de cod definește două variante ale funcției \c{factorial}:
\begin{enumerate}
\item un apel cu un singur parametru (asociat în interiorul funcției variabilei \c{zero}); șablonul testează ca acesta să fie egal cu \c{0}.
\item un apel cu un singur parametru (asociat în interiorul funcției variabilei \c{a}); nu există nici un șablon, deci această variantă se va potrivi oricărui apel cu un singur parametru.
\end{enumerate}

\section{Funcția \c{ref}}

Funcția \c{ref} este folosită pentru referirea la o funcție fără evaluarea acesteia. \c{ref} este utilă în cazuri în care se dorește manipularea funcțiilor, cum ar fi retunarea unei funcții sau trimiterea unei funcții ca argument. 

Un exemplu de cod în care \c{ref} e necesar este următorul:
\begin{code}
defun .make_adder .start {
  defun .add .increment {
    = .start (start .+ increment)
    start
  }
  ref .add
}
= .adder (make_adder 0)
adder 1 -> 1
adder 3 -> 4
adder 0 -> 4
adder 6 -> 10
\end{code}

În funcția \c{make\_adder} se dorește returnarea funcției, și nu apelarea acesteia.

\section{Instrucțiuni condiționale}

\subsection{Funcția \c{if}}

Funcția \c{if} primește 3 parametri: o valoare de test, un bloc sau o valoare pentru ramura True și un bloc sau o valoare pentru ramura False. 

Valorile pentru care funcția \c{if} execută ramura \c{False} sunt \c{null} și \c{false}. Orice altă valoare va duce la executarea ramurei \c{True}.

Odată aleasă ramura, dacă argumentul corespunzător este o valoare atunci aceasta este returnată. Dacă este un bloc, atunci el este evaluat iar rezultatul evaluării este returnat.

Fragmentul următor de cod oferă exemple de utilizare:
\begin{code}
= .a false
if a "a nu e null" "a e null"
  -> "a e null"
if a "a nu e null" { = a 1 }
  -> "a" va fi setat la valoarea 1
if a { print "a nu e null" } { print "a e null" }
  -> "a nu e null"
\end{code}

\subsection{Funcțiile \c{when} și \c{unless}}

Funcția \c{when} are 2 parametri: o condiție de test și un bloc care va fi evaluat în cazul în care condiția este True (diferită de \c{null} și \c{false}). Dacă condiția este False, \c{when} va returna valoarea \c{null}.
\begin{code}
when true { "da" }
  -> "da"
when false { "nu" }
  -> null
\end{code}

\c{unless} funcționează în mod invers, executând blocul doar dacă condiția este False:
\begin{code}
unless false { "nu" }
  -> "nu"
unless true { "da" }
  -> null
\end{code}

\section{Alte funcții}

\begin{description}
\item[\c{import}]\hfill\\ Funcția \c{import} este folosită la utilizarea bibliotecilor de clase .NET existente. Capitolul \ref{ch:IntegratingWithDotNet} explică această funcție în detaliu.
\item[\c{print}]\hfill\\ Funcția \c{print} afișează în consolă toate argumentele primite (cu\\ \c{Console.WriteLine}).
\item[\c{null}]\hfill\\ Funcția \c{null} întoarce valoarea nulă.
\item[\c{true} și \c{false}]\hfill\\ Aceste funcții întorc cele două posibile valori ale clasei \c{System.Boolean}: \c{True} și \c{False}.
\end{description}

Notă: Funcțiile \c{null}, \c{true} și \c{false} sunt necesare deoarece Bonsai nu deține o listă de cuvinte cheie.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Structuri de date}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Bonsai deține o sintaxă specială pentru declararea structurilor de date în codul sursă, definită de următoarele reguli în gramatici:
\begin{code}
# regula din gramatică
square_expr 
  : '[' datatype=atom SEPARATOR* (exp+=expression SEPARATOR*)* ']'
    -> ^(SQUARE $datatype $exp*)
    ;
# regula din gramatica de arbori:
expression returns [Expression result]
  ...
  | ^(SQUARE 
      { $result = new DataDecl(); }
      datatype=IDENTIFIER {
        ((DataDecl)$result).DataTypeId = $datatype.Text; }
      (e=expression {
        ((DataDecl)$result).Expressions.Add(e.result); })*)
  ...
\end{code}
După cum se poate observa, o structură de date este o listă de expresii cuprinsă între paranteze pătrate, tipul acesteia fiind descris de identificatorul \c{datatype}.

\section{Instanțierea structurilor}

Lista tipurilor de structuri nu este statică (hardcoded). Structurile de date suportate sunt conținute în variabila \c{dataHandlers} din contextul rădăcină. Tipul acesteia este \c{Dictionary<SymbolId, BonsaiFunction>>}. Pentru fiecare înregistrare din dicționar, cheia este un simbol echivalent cu identificatorul \c{datatype}, iar valoarea o funcție Bonsai (instanță a \c{BonsaiFunction}) care primește lista de expresii dintre parantezele pătrate și returnează o instanță a structurii.

Clasa \c{PreludeFunction} (contextul rădăcină) inițializează variabila \c{dataHandlers} odată cu restul funcțiilor standard.

\section{Liste}

Listele sunt una dintre cele două structuri de date care pot fi declarate în codul Bonsai pentru care există suport în biblioteca standard. Identificatorul asociat este \c{|}. Fragmentul următor oferă un exemplu de utilizare:
\begin{code}
= .numberList [| 1 2 3 ]
= .stringList [| "a" "b" "c" ]
= .mixedList [| 1 "a" .s ]
\end{code}

Toate listele declarate vor avea tipul \c{List<object>}. Din acest motiv, chiar dacă în declarație toate elementele au același tip, în listă vor putea fi adăugate instanțe de orice tip:

\begin{code}
= .list [| 1 2 3 ]
  -> [| 1 2 3 ]
list .Add "string"
  -> [| 1 2 3 "string" ]
list .Add .simbol
  -> [| 1 2 3 "string" .simbol ]
\end{code}

\section{Dicționare}

Dicționarele reprezintă cea de-a doua structură de date imlementată în biblioteca standard. Identificatorul asociat este \c{\#}. Lista elementelor cuprinse între paranteze pătrate conține pe pozițiile impare cheile, iar pe cele pare valorile. Dacă numărul de elemente este impar, atunci o excepție va fi aruncată.

Fragmentul următor oferă un exemplu de utilizare a dicționarelor:
\begin{code}
# dictionar cu cheile 3 symboluri și valorile 3 numere
= .dict [# .a 1 .b 3 .c 42 ]
dict .a 
  -> 1
dict .c
  -> 42

# dictionar cu cheile numere și valorile stringuri
= .weekdays [#
  1 "luni" 
  2 "marti" 
  3 "miercuri"
  4 "joi"
  5 "vineri"
  6 "sambata"
  7 "duminica"
]
weekdays 3
  -> "miercuri"
weekdays 9
  -> "duminica"
\end{code}

Dicționarele declarate vor avea tipul \c{Dictionary<object, object>}.

\section{Definirea unui nou tip de structuri de date}

Pentru adăugarea unei sintaxe noi pentru o altă structură de date trebuie ales un identificator asociat nefolosit și definită o funcție care convertește lista de expresii dintre parantezele pătrate într-o instanță a structurii.

Să presupunem că se dorește facilitarea lucrului cu instanțe ale clasei \c{System.Drawing.Color} și definirea unei sintaxe speciale pentru aceasta. Identificatorul ales este \c{rgb}. Codul pentru adăugarea handler-ului de culori este următorul:
\newpage
\begin{code}
loadAssembly "System.Drawing, Version=2.0.0.0, Culture=neutral,
    PublicKeyToken=b03f5f7f11d50a3a"
import .Color .System.Drawing.Color

defun .rgbDataHandler .r .g .b {
	Color .FromArgb r g b
}

dataHandlers .Add .rgb rgbDataHandler
\end{code}
Primele 3 linii încarcă assembly-ul \c{System.Drawing.dll} și importă clasa \c{Color} în contextul Bonsai. Urmeaza apoi definirea funcției \c{rgbDataHandler} care primește 3 parametri numiți \c{r}, \c{g} și \c{b} și returnează o instanță a clasei \c{Color}. Ultima linie conține adăugarea la dicționarul \c{dataHandlers} a acestei funcții cu identificatorul \c{rgb}. 

Odată înregistrată, noua sintaxă poate fi utilizată astfel:
\begin{code}
= .white [rgb 255 255 255 ]
print white
  -> Color [A=255, R=255, G=255, B=255]
print (white .GetType)
  -> System.Drawing.Color
\end{code}

\section{Combinarea structurilor}

O structură de date poate conține în lista de expresii alte structuri de date. Astfel se pot declara liste de dicționare, dicționare ale căror valori sunt liste, etc. De exemplu, următorul fragment de cod definește un dicționar de liste:
\begin{code}
= .listDict [#
  .prime [| 2 3 5 7 11 13 17 ]
  .odd [| 1 3 5 7 9 11 13 15 17 19 ]
  .even [| 2 4 6 8 10 12 14 16 18 ]
]
\end{code}

Acest mod de a combina structurile nu este limitat la liste și dicționare. Folosind structura pentru culori definită în secțiunea precedentă, putem defini un dicționar al culorilor astfel:
\begin{code}
= .basicColors [#
  .white [rgb 255 255 255 ]
  .black [rgb 0 0 0 ]
  .red [rgb 255 0 0 ]
  .green [rgb 0 255 0 ]
  .blue [rgb 0 0 255 ]
]
print (basicColors .black)
  -> Color [A=255, R=0, G=0, B=0]
print (basicColors .green)
  -> Color [A=255, R=0, G=255, B=0]
\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Primitive}\label{ch:Primitives}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Așa cum a fost menționat în secțiunea \ref{ch:runtime_sec:primitives}, primitivele în limbajul Bonsai sunt extensii aduse unor tipuri CLR. Capitolul curent conține lista completă a acestora.

\section{Numere}

Gramatică Bonsai nu definește o regulă specială pentru operatori infix. De aceea, operațiile matematice uzuale precum adunarea și scăderea sunt implementate ca primitive peste tipul \c{System.Decimal}. Sintaxa pentru efectuarea unei operații este astfel aceeasi cu apelarea metodelor unui număr: primul argument este un simbol care reprezintă operatorul, urmat de cel de-al doilea operand (numărul în sine reprezentând primul operand):
\begin{code}
1 .+ 3 
  -> 4
2 .^ 10
  -> 1024
\end{code}

Lista primitivelor definite pentru clasa \c{System.Decimal} este următoarea:

\begin{description}
\item[\c{.+}]\hfill\\ adunare
\item[\c{.-}]\hfill\\ scădere
\item[\c{.*}]\hfill\\ înmulțire
\item[\c{./}]\hfill\\ împărțire
\item[\c{.\textasciicircum}]\hfill\\ ridicare la putere
\item[\c{.\%}]\hfill\\ modulo
\item[\c{.round}]\hfill\\ rotunjire la cel mai apropiat întreg
\item[\c{.floor}]\hfill\\ rotunjire la întregul imediat inferior
\item[\c{.ceiling}]\hfill\\ rotunjire la întregul imediat superior
\end{description}

Notă: alte funcții matematice (\c{sin}, \c{cos}, \c{log}, etc) pot fi apelate prin importul clasei \c{System.Math} și apelarea metodelor sale statice (vezi capitolul \ref{ch:IntegratingWithDotNet}).

\subsection{Decimal, Int32, Double, etc.}

Toate constantele numerice din codul sursă Bonsai sunt parsate într-un singur tip de numere: raționale, reprezentate in virgulă fixă, mai precis tipul \c{System.Decimal} din .NET Framework. Motivația o reprezintă elimitarea erorilor cauzate de reprezentarea in virgulă mobilă:
\begin{code}
// C#
float a = 1000f;
float b = 0.0001f;
Console.WriteLine("{0:0000.0000}", a + b);
  -> 1000.0000
\end{code}
\begin{code}
# Bonsai
= .a 1000
= .b 0.0001
print (a .+ b)
  -> 1000.0001
\end{code}

Bonsai nu conține primitive numerice decât pentru tipul \c{System.Decimal}, toate celelate tipuri fiind convertite la acesta.

\section{Șiruri de caractere}

Șirurile de caractere din codul sursă Bonsai sunt parsate în instanțe ale clasei \c{System.String} din .NET Framework. Lista primitivelor definite pentru acesta este:

\begin{description}
\item[\c{.capitalize}]\hfill\\Transformă în majusculă prima literă din fiecare cuvânt
\item[\c{.+}]\hfill\\Întoarce un nou șir obținut prin contactenarea strigului apelat cu toate argumentele primite.
\end{description}

Notă: metodele clasei \c{System.String} pot fi apelate în continuare:
\begin{code}
"bonsai" .ToUpper
  -> "BONSAI"
\end{code}

\section{Liste și dicționare}

\subsection{Primitive pentru tipul \c{IList<T>}}
\begin{description}
\item[\c{.shuffle}]\hfill\\Crează o copie a listei și rearanjează elementele pe poziții aleatoare.
\item[\c{.join}]\hfill\\Crează un șir de caractere care va conține toate elementele listei. Separatorul este primit ca argument.
\end{description}

\subsection{Primitive pentru tipul \c{IDictionary<TKey, TValue>}}
\begin{description}
\item[\c{.tolist}]\hfill\\Convertește un dicționar într-o listă de tipul \c{List<Tuple<T1,T2>>}.
\end{description}

\subsection{Indexarea}

Listele și dicționarele au în plus asociate câte o primitivă „specială” care este apelată de Binder ca ultimă instanță, în cazul în care rezolvarea apelului a eșuat pentru toate celelalte posibilități. Aceste primitive sunt folosite pentru indexare și așteaptă fie un index (pentru liste), fie o cheie (pentru dicționare).

Fragmentul de mai jos ofera atât exemple de indexare obișnuită, prin apelarea proprietății \c{Item}, dar și de indexare prin utilizare acestor primitive:
\begin{code}
= .list [| 1 2 3 ]
# accesarea obisnuită a indexerului
list .Item 0
  -> 1
# apelarea primitivei
list 0
  -> 1
= .dict [# .a 1 .b 2 .c 3 ]
# accesarea proprietatii Item
dict .Item .a
  -> 1
# apelarea primitivei
dict .a 
  -> 1
\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Programarea orientată obiect}\label{ch:oop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Spre deosebire de limbajele orientate obiect, unde orice instanță este un obiect, în Bonsai orice instanță este o funcție. Această diferență poate părea fundamentală, dar o funcție poate fi considerată generalizarea unui obiect. În secțiunile următoare se va arăta cum multe dintre principiile programării orientate obiect pot fi „simulate” cu ajutorul apelurilor de funcții și al convențiilor de nume.

\section{Trimiterea mesajelor}

Baza programarii orientate obiect o reprezintă message-passing-ul. Acesta este emulat în Bonsai printr-un apel de funcție în care primul parametru este un simbol. Funcția reprezintă obiectul, iar simbolul mesajul trimis. De exemplu, un string apelat cu simbolul \c{.ToUpper} va returna un nou string cu toate caracterele transformate în majuscule:
\begin{code}
"bonsai" .ToUpper
  -> "BONSAI"
\end{code}
Acest cod Bonsai are același efect cu următorul cod C\#:
\begin{code}
"bonsai".ToUpper()
\end{code}
În cazul în care mesajul are mai mulți parametri, aceștia urmează după simbol:
\begin{code}
stringBuilder .Append " sfarsit"
\end{code}
\c{stringBuilder} este o variabilă ce conține instanța apelată, \c{Append} este mesajul trimis (și, în cazul obiectelor CLR, numele metodei apelate) iar \c{" sfarsit"} este unicul parametru trimis funcției.

\section{Programarea bazată pe prototipuri}

Bonsai implementează un model foarte simplu de programare bazată pe prototipuri\cite{prototype_based_programming} inspirat din JavaScript, spre deosebire de majoritatea limbajelor, care utilizeaza programarea bazată pe clase. Într-un model OOP bazat pe prototipuri, fiecare obiect are propria listă de metode (mesaje) la care poate răspunde. Obiectele noi sunt create prin clonarea unui obiect existent (numit prototip) și moștenirea comportamentului (a metodelor) acestuia. Conceptul de „clasă” nu există, deși unele obiecte pot fi definite pentru a funcționa într-un mod similar. 

\section{Crearea prototipurilor în Bonsai}

Prototipul din care moștenesc toate obiectele Bonsai este stocat în variabila \c{object} din contextul rădăcină. Aceasta conține cele trei metode comune tuturor obiectelor: \c{clone}, \c{field} și \c{method}.

\subsection{Metoda \c{clone}}

Metoda \c{clone} crează o clonă a obiectului apelat prin copierea tuturor metodelor și a câmpurilor într-un nou obiect. 
\begin{code}
= .ShapeProto (object .clone)
= .RectangleProto (ShapeProto .clone)
\end{code}

\subsection{Metodele \c{method} și \c{field}}

Obiectului clonat i se pot adăuga metode noi prin apelarea metodei \c{method}. Aceasta primește ca prim argument numele metodei ce urmeaza a fi definită, urmat de numele parametrilor și, la final, blocul asociat. În interiorul acestul bloc obiectul curent este conținut în variabila \c{self}.

Metoda \c{field} este folosită pentru setarea valoarii unui câmp și primește ca parametri numele câmpului și valoarea acestuia.

Fragmentul următor de cod adaugă prototipului \c{RectangleProto} metoda \c{area}, care returnează înmulțirea câmpurilor \c{width} și \c{height} a obiectului apelat:
\begin{code}
# defineste metoda area 
RectangleProto .method .area { 
  (self .height) .* (self .width)
}
# creaza o clona (sau instanta) a RectangleProto
= .rectangle (RectangleProto .clone)
# defineste campurile width si height
rectangle .field .width 4
rectangle .field .height 5
# acceseaza campul width
rectangle .width
  -> 5
# apeleaza metoda area
rectangle .area
  -> 20
\end{code}

Notă: după clonare, obiectul nou creat nu păstreaza legătura cu prototipul. Astfel, adăugarea metodelor sau câmpurilor într-un prototip nu se va reflecta și în obiectele clonate anterior din acesta.

\section{Principiile OOP în programarea bazată pe prototipuri}

\subsection{Moștenirea}

Moștenirea într-un sistem OOP bazat pe prototipuri se realizează prin clonarea obiectelor: clonele moștenesc metodele și câmpurile definite în prototip. De exemplu, în fragmentul de mai sus, obiectul \c{rectangle} moștenește metoda \c{area} de la prototipul \c{RectangleProto}.

\subsection{Încapsularea}

Bonsai nu oferă suport explicit pentru definirea metodelor non-publice. Este utilizată în schimb convenția ca orice metodă al cărui nume începe cu caracterul „\c{\_}” (liniuță-jos) să fie considerată \c{private} și să nu fie niciodată apelată din exteriorul obiectului.

Notă: aceeași convenție este folosită și de limbajul Python\cite{python_classes}.

\subsection{Polimormismul}

Polimorfismul se poate obține în Bonsai prin definirea unor metode cu acelasi nume și aceeași listă de parametri în mai multe obiecte (sau prototipuri). Între acestea nu este necesar să existe o legătură, așa cum de exemplu în Java toate instanțele trebuie să moștenească aceeași clasă sau interfață de bază.

Următorul fragment de cod oferă un exemplu de apelare a metodei \c{area}, definită separat pentru cercuri și pătrate:
\begin{code}
= .PI 3.14159
= .CircleProto (object .clone)
= .SquareProto (object .clone)
# defineste metoda "area" pentru cercuri
CircleProto .method .area {
  PI .* ((self .radius) .^ 2)
}
# defineste metoda "area" pentru patrate
SquareProto .method .area { 
  (self .side) .^ 2 
}
# defineste o functie care afiseaza aria pentru orice forma
defun .printArea .shape { 
  print (shape .area)
}
# creaza un cerc de raza 5
= .circle1 (CircleProto .clone)
circle1 .field .radius 5
# creaza un patrat cu latura 10
= .square1 (SquareProto .clone)
square1 .field .side 10
# apeleaza functia "printArea" pentru cerc si patrat
printArea circle1
  -> 78.53975
printArea square1
  -> 100
\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Integrarea cu platforma .NET}\label{ch:IntegratingWithDotNet}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Unul din principale avantajele în utilizarea runtime-ului .NET este posibilitatea de a folosi bibliotecile disponibile. În secțiunea \ref{sec:invoking_clr_members} a fost descris modul în care sunt tratate apelurile către instanțe ale claselor din CLR, dar nu s-a menționat nimic despre metode și proprietăți statice sau despre încărcarea bibliotecilor. Acest capitol descrie funcțiile standard care acoperă aceste cazuri.

\section{Încărcarea bibliotecilor}

Înainte de a putea importa și utiliza tipurile din ea, o bibliotecă .NET trebuie încărcată în runtime-ul .NET folosind una dintre cele doua funcții din Bonsai:

\subsection{Funcția \c{loadAssembly}}

Funcția \c{loadAssembly} primește ca unic parametru numele complet al unei biblioteci .NET:
\begin{code}
loadAssembly "System.Drawing, Version=2.0.0.0, Culture=neutral, 
              PublicKeyToken=b03f5f7f11d50a3a"
\end{code}
\c{loadAssembly} poate fi folosită pentru încărcarea unui assembly standard din .NET Framework, cum ar fi \c{System.Data.dll}, sau orice altă bibliotecă din GAC (global assembly cache).

\subsection{Funcția \c{loadAssemblyFile}}
Funcția \c{loadAssemblyFile} primește de asemenea un singur parametru, calea către un fișier \c{.dll} sau \c{.exe} care reprezintă biblioteca ce se dorește a fi încărcată:
\begin{code}
loadAssemblyFile ".\Lib\MyLibrary.dll"
\end{code}
\c{loadAssembly} poate fi utilizată pentru încărcarea unui assembly non-standard, cum ar fi module proprii sau biblioteci open-source.

\section{Funcția \c{import}}

Funcția \c{import} este folosită pentru importul spațiilor de nume și al claselor și are antetul:
\begin{code}
defun .import .alias .typeName { ... }
\end{code}
Parametrului \c{typeName} acceptă ca valoare string-uri sau simboluri. Funcția \c{import} încearcă mai întâi să găsească o clasă cu același nume, apoi, în cazul în care căutarea a eșuat, consideră că apelul reprezintă importul unui spațiu de nume.

\subsection{Importul claselor}

Vom considera întâi cazul în care parametrul \c{typeName} conține numele unei clase. În acest caz se va crea o nouă instanță a clasei \c{BonsaiClrClassFunction} care va fi salvată într-o variabilă din contextul curent. Numele variabilei este specificat prin parametrul \c{alias}. 

Clasa \c{BonsaiClrClassFunction} implementează o funcție specifică Bonsai care redirectează toate apelurile proprii către membri statici ai unei clase CLR, similar modului în care binder-ul \c{BonsaiBinder} redirectează apelurile dinamice către membrii instanțelor de obiecte CLR: Primul parametru din apel este un simbol care reprezintă o proprietate sau o metodă statică, în timp ce restul argumentelor sunt considerate valori ale parametrilor acesteia. 

Mecanismul de căutare a membrilor este analog celui descris în secțiunea \ref{sec:invoking_clr_members}.

Fragmentul următor de cod oferă câțeva exemple de utilizare:
\begin{code}
# clasa System.Environment este importata in variabila env
import .env .System.Environment
# apel al proprietatii statice CurrentDirectory
env .CurrentDirectory
  -> "C:\Users\Eugen\Projects"
# apel al metodei statice GetEnvironmentVariable
env .GetEnvironmentVariable "SYSTEMROOT"
  -> "C:\Windows"
\end{code}

\subsection{Instanțierea obiectelor}

Pe lângă invocarea proprietăților și metodelor statice, clasa \c{BonsaiClrClassFunction} implementează următorul caz particular: dacă primul parametru conține simbolul \c{.new}, atunci se consideră că apelul reprezintă invocarea unui constructor. Regulile de potrivire a argumentelor peste metode CLR rămân aceleași, căutarea având loc în schimb pe lista de constructori ai clasei.

Exemplu de instanțiere a clasei \c{ArrayList}:
\begin{code}
import .arraylist .System.Collections.ArrayList
# instantiaza un nou ArrayList in variabila l
= .l (list .new)
l .GetType
  -> System.Collections.ArrayList
\end{code}

\subsection{Importul spațiilor de nume}

Dacă funcția \c{import} nu găsește nici o clasă cu numele specificat în argumentul \c{typeName}, atunci apelul este considerat importul unui spațiu de nume. O instanță a clasei \c{BonsaiClrNamespaceFunction} este creată și salvată în contextul curent, într-o variabilă cu numele specificat de argumentul \c{alias}.

Clasa \c{BonsaiClrNamespaceFunction} este o funcție specifică Bonsai care reprezintă un spațiu de nume. Unicul parametru acceptat este un simbol. În momentul apelării, o clasă cu numele specificat în argument este căutată în spațiul de nume asociat, iar o nouă instanță de \c{BonsaiClrClassFunction} este creată din această clasă.

Importul separat al unui spațiu de nume este util în cazul în care mai multe clase din același namespace sunt necesare. Un exemplu ar fi importul mai multor tipuri de colecții din \c{System.Collections}:
\begin{code}
# importul spatiului de nume 
import .collections .System.Collections
# importul clasei ArrayList
= arraylist (collections .ArrayList)
# importul clasei HashTable
= hashtable (collections .HashTable)
# import clasei Stack
= stack (collections .Stack)
\end{code}

Utilizarea claselor importate din spațiul de nume se face exact ca în cazul claselor importate direct:
\begin{code}
= .arr (arraylist .new)
arr .Add 10
= .table (hashtable .new)
table .Add 1 "monday"
table .Add 2 "tuesday"
\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Posibile îmbunătățiri}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Module}

În stadiul actual, Bonsai nu oferă nici o posibilitate de structurare a codului în mai multe module, assembly-uri sau spații de nume, funcționalitate absolut necesară oricărui limbaj de uz general.

Metoda cea mai potrivită pentru împărțirea codului Bonsai dintre cele menționate mai sus ar fi modulele — similare celor din limbajul Python. 

\section{Metaprogramare}

\subsection{Modificarea codului sursă la rulare} 

Familia de limbaje Lisp suportă definirea de macrouri, funcții speciale care rulează la compilare și care pot modifica codul existent sau chiar genera un alt cod arbitrar, motiv pentru care sunt una dintre cele mai apreciate variante de metaprogramare. O variantă similară, care beneficiază de aceeași flexibilitate, o reprezintă funcțiile care își pot modifica comportamentul la rulare. 

Datorită utilizării Dynamic Language Runtime-ului, codul sursă Bonsai este oricum parsat și compilat la rulare, ceea ce face posibilă implementarea mecanismului menționat mai sus printr-un set de modificări aduse parserului și generatorului de expresii LINQ — clasa \c{Generator}. Astfel, orice obiect sau funcție specifică din Bonsai ar putea avea codul sursă accesibil la rulare. 

Un set de funcții standard ar putea fi definite pentru obținerea, modificarea și recompilarea codului:

\begin{description}
\item[\c{getSourceCode .object}]\hfill\\ Întoarce codul sursă pentru un obiect Bonsai.
\item[\c{getCurrentContext}]\hfill\\ Întoarce contextul curent. Folosit pentru recompilarea unui fragment de code.
\item[\c{compileCode .codeFragment .scope}]\hfill\\ Compilează un fragment de cod în contextul specificat de argumentul \c{scope}. 
\end{description}

Folosind aceste funcții standard, o funcție Bonsai și-ar putea accesa propriul cod sursă și aplica modificări asupra lui, pentru ca apoi să se înlocuiască singură cu o versiune modificată a sa prin recompilarea codului.

\subsection{Modificarea AST-ului la rulare}

Pe lângă codul sursă, există posibilitatea de a oferi un set de funcții pentru obținerea și recompilarea arborilor de sintaxă abstractă. Comparat cu lucrul direct cu codul sursă, manipularea arborilor de sintaxă poate fi considerată „în spiritul Lisp”, similară manipulării S-expresiilor.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{appendices}

\fvset{numbers=left,labelposition=all,frame=lines}

\chapter{Gramatica limbajului Bonsai}
\label{app:grammar}
\VerbatimInput[label=Bonsai.g]{../src/Grammars/Bonsai.g}

\chapter{Gramatica de arbori}
\label{app:tree_grammar}
\VerbatimInput[label=BonsaiTree.g]{../src/Grammars/BonsaiTree.g}

\end{appendices}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{bonsai}
\bibliography{bonsai}{}

\end{document}

