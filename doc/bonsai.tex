\documentclass[12pt,a4paper]{report}
\usepackage{url}

\title{Bonsai\\Un limbal dinamic fun\c tional peste DLR}

\begin{document}
\maketitle
\tableofcontents

\chapter{Introducere}

In ultimele doua decenii, programarea a fost in mare parte impartita intre doua grupe de limbaje. Limbajele imperative, cu un sistem static de tipuri, multe din ele din familia C, au fost folosite pentru a obtine performanta si scalabilitate. In schimb, flexibilitatea limbajelor precum PHP si Perl a fost apreciata pentru programarea scripturilor de sistem, a paginilor web si a altor programe pentru care eficienta nu reprezinta o prioritate.

In ultimii ani insa, odata cu reducerea exponentiala a costurilor hardware-ului multumita legii lui Moore, accentul a inceput sa se puna din ce in ce mai putin pe eficienta si din ce in ce mai mult pe timpul de dezvoltare. Performanta limbajelor dinamice a devenit ``suficienta'', ceea ce a condus la o adevarata renastere a acestora.

Atat Sun cat si Microsoft si-au aratat interesul pentru limbajele dinamice prin proiectele The Da Vinci Machine\cite{daVinciMachine} si Dynamic Language Runtime (DLR)\cite{dlr} si sprijinirea dezvoltarii limbajelor JRuby\cite{jruby}, Jython\cite{jython}, IronRuby\cite{ironruby}, IronPython\cite{ironpython}, etc.

Lucrarea de fata prezinta un limbaj dinamic numit Bonsai. Cea mai importanta caracteristica a sa este simplitatea, limbajele Lisp si Io \cite{io} reprezentand principalele surse de inspiratie. Platforma aleasa este .NET impreuna cu Dynamic Language Runtime, intreaga suita de biblioteci .NET fiind astfel disponibila, indiferent de limbajul in care au fost scrise. Bonsai este un limbaj functional, dar se integreaza bine cu alte limbaje orientate obiect prin simularea OOP-ului prin apeluri de functii. Datorita platformei pe care ruleaza si a utilizarii de biblioteci scrise in alte limbaje, transparenta referentiala a functiilor nu poate fi garantata. Programarea fara efecte laterale este in schimb incurajata: majoritatea primitivelor din Bonsai sunt functii pure, iar cele care modifica starea sunt clar
denumite astfel incat acest lucru sa-i fie vizibil programatorului.

\chapter{Primitivele limbajului}

Spre deosebire de proiecte precum IronPython si IronRuby, care au fost nevoite sa implementeze intreaga biblioteca disponibila in implementarile ``originiale'' (MRI si CPython), Bonsai incearca sa foloseasca cat mai mult clasele din .NET Framework si sa mentina biblioteca proprie de functii cat mai mica.

\section{symbol}

Tipul \texttt{symbol} din Bonsai este foarte asemanator simbolurile din din Ruby\cite{ruby_symbols} si Lisp\cite{clhs_symbols}. Un simbol se comporta de cele mai multe ori ca un string. Diferenta majora consta in faptul ca pentru orice string exista o singura instanta a unui simbol cu acel string, ceea ce transforma compararea a doua simboluri intr-o comparatie de pointeri, foarte rapida. De asemenea, utilizarea unui simbol indica de cele mai multe ori folosirea metaprogramarii. 

\section{list}

Functia \texttt{list} creaza o lista. Majoritatea apelurilor catre o lista intorc (unde este cazul) o instanta noua, fara sa modifice lista originala. Toate operatiile pe liste binecunoscute in limbajele functionale (\texttt{map, reduce, foldl, foldr,} etc) sunt disponibile.

\section{block}

Un \texttt{block} este un set de instructiuni impreuna cu o lista de variabile locale definite in el. Un block poate fi evaluat direct, dar si analizat sau modificat la runtime, pentru a obtine un alt block.

\section{number}

In Bonsai exista un singur tip de numere: rationale, reprezentate in virgula fixa. Acesta mapeaza peste tipul \texttt{System.Decimal} din .NET Framework. Erorile cauzate de reprezentarea in virgula mobila (ex. \texttt{1.1 + 1.1 + 1.1 == 3.300000000007}) sunt astfel eliminate.

\chapter{Sintaxa}

enter pieces of grammar here

\chapter{Semantica}

Spre deosebire de limbajele Io\cite{io} si SmallTalk\cite{smalltalk}, unde orice este un obiect, in Bonsai orice este considerat o functie. Mai mult, daca in SmallTalk si Io orice expresie reprezinta trimiterea unui mesaj catre un obiect, iar rezultatul tot un obiect, in Bonsai orice expresie este un apel de functie, iar rezultatul tot o functie. 

Aceasta diferenta poate parea fundamentala, dar o functie poate fi considerata generalizarea unui obiect. Intreaga paradigma OOP este ``simulata'' in Bonsai cu ajutorul functiilor. In sectiunile urmatoare se va face o detaliere pe larg a acestei comparatii. 

\section{Functional versus OOP}

Baza programarii orientate obiect o reprezinta message-passing-ul. Acesta este ``simulat'' in Bonsai printr-un apel de functie in care primul parametru este un simbol. Functia reprezinta obiectul, iar simbolul mesajul trimis. 

Spre exemplu, un string apelat cu simbolul \texttt{:to-upper} va returna un nou string cu toate caracterele transformate in majuscule. 

Mostenirea poate fi simulata printr-o functie care este definita doar pentru un set de pattern-uri peste parametri, apelurile cu alti parametri fiind redirectate la o alta functie (analogul clasei de baza).

Tratarea mesajelor in acest fel poate parea primitiva si greoaie, dar in practica nu se face niciodata o tratare manuala (de tip ``case''): toate operatiile OOP ``clasice'' sunt abstractizate printr-un set de functii incluse in limbaj.

\bibliography{bonsai}{}
\bibliographystyle{plain}


\end{document}