\documentclass[12pt,a4paper]{memoir}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{fontspec} 
\usepackage{xunicode}
\usepackage[dvipsnames]{color}
\usepackage{xltxtra}
\usepackage[romanian]{babel}
\usepackage{hyperref}

\hyphenpenalty=5000
\tolerance=1000

\setmainfont{Calluna}
\setmonofont{Inconsolata}

\fvset{numbers=left,labelposition=all,frame=lines}

\definecolor{shadecolor}{named}{Gray}

\title{Bonsai\\Un limbal dinamic funcțional peste DLR}
\author{Eugen Anghel}

\begin{document}

\newcommand{\draft}{\textcolor{red}}

% footnotes with symbols instead of numbers %
\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\maketitle

\newpage
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Introducere}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

În ultimele doua decenii, programarea a fost în mare parte împărțită între două grupe de limbaje. Limbajele imperative, cu un sistem static de tipuri, multe dintre ele din familia C, au fost folosite pentru a obține performanță și scalabilitate. În schimb, flexibilitatea limbajelor precum Perl si PHP a fost apreciată pentru programarea scripturilor de sistem, a paginilor web și a altor programe pentru care eficiența nu reprezintă o prioritate.

În ultimii ani însă, odată cu reducerea exponențială a costurilor hardware-ului — mulțumită legii lui Moore — accentul a început să se pună din ce în ce mai puțin pe eficiență și din ce în ce mai mult pe timpul de dezvoltare. Performanța limbajelor dinamice a devenit „suficientă”, ceea ce a condus la o adevărată renaștere a acestora.

Atât Sun cât și Microsoft și-au arătat interesul pentru limbajele dinamice prin proiectele The Da Vinci Machine\cite{daVinciMachine} și Dynamic Language Runtime (DLR)\cite{dlr} și sprijinirea dezvoltării limbajelor JRuby\cite{jruby}, Jython\cite{jython}, IronRuby\cite{ironruby}, IronPython\cite{ironpython}, etc.

Lucrarea de față prezintă un limbaj dinamic numit Bonsai. Cea mai importantă caracteristică a sa este simplitatea, limbajele Lisp, Javascript și Io \cite{io} reprezentând principalele surse de inspirație.

Platforma aleasă este .NET Framework, împreună cu Dynamic Language Runtime. Întreaga suită de biblioteci .NET este astfel disponibilă, indiferent de limbajul in care au fost ele scrise. 

Bonsai este un limbaj funcțional\footnote{Datorită utilizării bibliotecilor .NET, transparența referențială a funcțiilor nu poate fi garantată. Bonsai nu este, așadar, pur funcționl.}, dar se integrează bine cu alte limbaje orientate obiect. OOP-ul este simulat în întregime prin apeluri de funcții. \draft{Programarea fără efecte laterale este în schimb încurajată: majoritatea primitivelor din Bonsai sunt funcții pure, iar cele care modifica starea sunt clar denumite astfel încât acest lucru să-i fie vizibil programatorului}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Parsarea și generarea arborilor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Scurtă descriere a ANTLR}

ANTLR 3.1\cite{antlr} este un instrument pentru construcția compilatoarelor și a translatoarelor care utilizează algoritmul de parsare \texttt{LL(*)} cu predicate\cite{definitive_antlr_reference}. Comparat cu ANTLR 2 (bazată pe algoritmul \texttt{LL(k)}), numărul de gramatici ce pot fi parsate este cu mult îmbunătățit. Parserele generate sunt descendente-recursive, iar lista de limbaje suportate\cite{antlr_targets} include C, C\#, Java, Python și Javascript.

În plus, ANTLR 3.1 oferă suport pentru efectuarea de transformări arbitrare asupra arborilor: pornind de la arborele de parsare, mai multe gramatici de arbori pot fi înlănțuite pentru a obține un arbore de sintaxă abstractă cât mai convenabil sau pentru aplicarea a diverse optimizări\cite{antlr_tree_grammars}.

Bonsai ANTLR 3.1 pentru parsarea codului sursă și pentru generarea AST-ului din arborele de parsare. 

\section{Parsarea codului sursă}

Simplitatea limbajului se reflectă în dimensiunile gramaticii: aceasta are doar 18 reguli de parsare (inclusiv lexerul) și nici un cuvânt nu este rezervat\footnote{Gramatica de parsare este listată în întregime în Anexa \ref{app:grammar}}. În urma aplicării unei reguli rezultă un arbore de parsare, generat conform instrucțiunilor din gramatică. Acesta conține încă un număr ridicat de artefacte și nu poate fi considerat un arbore de sintaxă abstractă.

Din gramatică au fost generate clasele \texttt{BonsaiParser} și \texttt{BonsaiLexer}. Următorul fragment oferă un exemplu de utilizare:

\begin{Verbatim}
var text = "... Bonsai code ...";
var strStream = new ANTLRStringStream(text);
var lexer = new BonsaiLexer(strStream);
var tokStream = new CommonTokenStream(lexer);
var parser = new Generated.BonsaiParser(tokStream);
var returnValue = parser.program();
\end{Verbatim}

Metoda \texttt{program} semnifică aplicarea regulei cu același nume. După rulare, \texttt{returnValue.Tree} va conține arborele de parsare.

\section{Generarea AST-ului}

Pe lângă gramatica de parsare, Bonsai utilizează și o gramatica de arbori, de doar 3 reguli\footnote{Gramatica de arbori este listată în întregime în Anexa \ref{app:tree_grammar}}, care transformă arborele de parsare într-un arbore de sintaxă abstractă. Clasa generată este \texttt{BonsaiTree}.

Fragmentul următor este continuarea codului din secțiunea precedentă și arată aplicarea gramaticii de arbori pe rezultatele parsării:

\begin{Verbatim}
var tree = (CommonTree)returnValue.Tree;
var treeNodeStream = 
    new CommonTreeNodeStream((CommonTree)returnValue.Tree);
var treeWalker = new Generated.BonsaiTree(treeNodeStream);
List<Call> statements = treeWalker.program().result.Statements;
\end{Verbatim}

După rulare, variabila \texttt{statements} va conține o listă de instanțe ale clasei \texttt{Call}.

Este important de observat că rezultatul aplicării gramaticii de arbori reprezintă chiar instanțe de clase din namespace-ul \texttt{Bonsai.Ast}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Runtime-ul Bonsai}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\draft{Introducere în DLR}}

\section{Generarea de expresii LINQ}

\draft{Odată obținut AST-ul, următorul pas este transformarea acestuia în expresii LINQ\cite{linq_expressions}. Clasa răspunzătoare este \texttt{Bonsai.Runtime.Generator}.}

\section{\draft{BonsaiBinder}}

\section{\draft{Tratarea tipurilor de date primitive}}

\section{\draft{Rezolvarea metodelor .NET}}

\section{\draft{Tipul BonsaiFunction}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Biblioteca de funcții standard}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Spre deosebire de proiecte precum IronPython si IronRuby, care au fost nevoite sa implementeze întreaga biblioteca disponibilă în implementarile „originale” (MRI\cite{ruby_mri} si CPython\cite{cpython}), Bonsai încearcă să folosească cât mai mult clasele din .NET Framework și să mențină biblioteca proprie de funcții cât mai mică.

\section{Numere}

În Bonsai există un singur tip de numere: raționale, reprezentate in virgulă fixă. Acesta mapează peste tipul \texttt{System.Decimal} din .NET Framework. Erorile cauzate de reprezentarea in virgulă mobilă (ex. \texttt{1.1 + 1.1 + 1.1 == 3.300000000007}) sunt astfel eliminate.

\begin{tabular} { | r | l | }
  \hline
  symboluri & descriere \\
  \hline
  .\texttt{+, .-, .*, ./} & adunare, scădere, înmulțire, împărțire \\
  .\texttt{\textasciicircum} & ridicare la putere \\
  \hline
\end{tabular}

\section{Șiruri de caractere}

Șirurile de caractere din Bonsai sunt instanțe ale clasei \texttt{System.String} din .NET.

\begin{tabular} { | r | l | }
  \hline
  symboluri & descriere \\
  \hline
  .\texttt{upcase} & Transformă toate caracterele în majuscule \\
  .\texttt{downcase} & Transformă toate caracterele în litere mici \\
  .\texttt{capitalize} & Transformă în majusculă prima literă din fiecare cuvânt \\
  .\texttt{contains} & Întoarce \texttt{true} dacă șirul conține subșirul căutat \\
  .\texttt{+} & Întoarce un nou șir obținut prin contactenarea strigului apelat cu argumentele \\
  .\texttt{} &  \\
  \hline
\end{tabular}

\section{Symboluri}

Tipul \texttt{symbol} din Bonsai este foarte asemănător simbolurilor din Ruby\cite{ruby_symbols} și Lisp\cite{clhs_symbols}. Un simbol se comportă de cele mai multe ori ca un string. Diferența majoră constă în faptul că pentru orice string există o singură instanță a unui simbol cu acel string, ceea ce face compararea a două simboluri foarte rapidă. De asemenea, utilizarea unui simbol indică de cele mai multe ori folosirea metaprogrămarii.

\section{Blocuri}

Un \texttt{block} este un set de instrucțiuni împreună cu o listă de variabile locale definite in el. 

\draft{Un \texttt{block} poate fi evaluat direct, dar și analizat sau modificat la runtime, pentru a obține un alt block.}

\section{Funcții}

\section{Pattern-Matching}

\section{\draft{Structuri de date}}

\draft{Funcția \texttt{list} crează o listă. Majoritatea apelurilor către o listă întorc (unde este cazul) o instanță nouă, fără să modifice lista originală. Toate operațiile pe liste binecunoscute în limbajele funcționale (\texttt{map, reduce, foldl, foldr,} etc) sunt disponibile și în Bonsai.}

\section{Funcții de ordin superior}

\subsection{combine}

\subsection{apply}

\subsection{papply}

\subsection{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Bonsai și Programarea Orientată Obiect}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Spre deosebire de limbajele Io\cite{io} și SmallTalk\cite{smalltalk}, unde orice este un obiect, în Bonsai orice este o funcție. Mai mult, dacă în SmallTalk și Io orice expresie reprezintă trimiterea unui mesaj către un obiect, iar rezultatul tot un obiect, în Bonsai orice expresie este un apel de funcție, iar rezultatul tot o funcție.

Această diferență poate părea fundamentală, dar o funcție poate fi considerată generalizarea unui obiect. În secțiunile următoare vom vedea cum toate cele trei principii fundamentale OOP – moștenirea, encapsularea și polimorfismul – sunt „simulate” în Bonsai cu ajutorul funcțiilor.

\section{Paralela funcțional <-> OOP}

Baza programarii orientate obiect o reprezinta message-passing-ul. Acesta este emulat în Bonsai printr-un apel de funcție în care primul parametru este un simbol. Funcția reprezintă obiectul, iar simbolul, mesajul trimis. Spre exemplu, un string apelat cu simbolul \texttt{:upcase} va returna un nou string cu toate caracterele transformate în majuscule:
\begin{Verbatim}
"bonsai!" .upcase
\end{Verbatim}
Acest cod Bonsai are același efect cu următorul cod C\#:
\begin{Verbatim}
"bonsai".ToUpper()
\end{Verbatim}
În cazul în care mesajul are mai mulți parametri, aceștia urmează după simbol:
\begin{Verbatim}
stringBuilder .Append " ultima parte "
\end{Verbatim}


Moștenirea poate fi simulată printr-o funcție care este definită doar pentru un set de pattern-uri peste parametri, apelurile cu alți parametri fiind redirectate către o alta funcție (analogul clasei de bază).

Tratarea mesajelor în acest fel poate părea primitivă și greoaie, dar în practică nu se face niciodată o tratare manuală (de tip \texttt{case}): toate operațiile OOP „clasice” sunt abstractizate printr-un set de funcțtii incluse în biblioteca standard a limbajului.

\section{Creerea prototipurilor}

\section{Clonarea instanțelor noi din prototipuri}

\draft{Metoda \texttt{clone}}

\section{Encapsularea}

\draft{Dicționarele \texttt{private} și \texttt{protected}}

\section{Polimormism?}

\draft{Limbaj dinamic = polimorfism implicit (?)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Integrarea cu platforma .NET}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{primitiva \texttt{import}}

\section{Spații de nume și clase statice}

\section{Instanțierea obiectelor}

\section{Pasarea funcțiilor Bonsai către metode .NET}

\section{Integrarea cu alte limbaje dinamice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Părți lipsă și îmbunătățiri pentru viitor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Module}

\section{Spații de nume}

\section{Metaprogramare}

\draft{inspectarea codului sursă al funcțiilor la rulare; modificarea și recompilarea acestuia}

\draft{similar, modificarea și recompilarea AST-ului la rulare}

\draft{posibilitatea evaluării non-stricte a argumentelor (à la Haskell); avantaje/dezavantaje}

\section{Debugger}

\draft{posibilități de realizare a unui debugger; integrarea cu VisualStudio}

\section{Îmbunătățirea performanței}

\section{Tratarea excepțiilor}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{appendices}

\chapter{Gramatica Bonsai}
\label{app:grammar}
\VerbatimInput[label=Bonsai.g]{../src/Grammars/Bonsai.g}

\chapter{Gramatica de arbori}
\label{app:tree_grammar}
\VerbatimInput[label=BonsaiTree.g]{../src/Grammars/BonsaiTree.g}

\end{appendices}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{unsrt}
\bibliography{bonsai}{}

\end{document}
