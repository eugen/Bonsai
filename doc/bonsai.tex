\documentclass[12pt,a4paper]{memoir}
\usepackage[romanian]{babel}
\usepackage[dvipsnames]{color}
\usepackage{fancyvrb,fontspec,xunicode,xltxtra,hyperref,url,framed,verbatim}

\hyphenpenalty=5000
\tolerance=1000

\setmainfont{Calluna}
\setmonofont{Inconsolata}

\definecolor{shadecolor}{named}{Gray}

\hypersetup{pdftitle={Bonsai - Un limbaj dinamic funcțional peste DLR},citebordercolor={0.8 0 0},filebordercolor={0.8 0 0},linkbordercolor={0.8 0 0},menubordercolor={0.8 0 0},urlbordercolor={0.8 0 0},runbordercolor={0.8 0 0}}

% include subsections in the TOC %
\setcounter{tocdepth}{4}

\title{Bonsai\\Un limbal dinamic funcțional peste DLR}
\author{Eugen Anghel}

\begin{document}

\newcommand{\draft}{\textcolor{red}}

% footnotes with symbols instead of numbers %
\renewcommand{\thefootnote}{\fnsymbol{footnote}}

% we don't use cedillas, so just redifine \c as \texttt
% this is probably not ``politically correct''
\renewcommand{\c}{\texttt}

% define a new environment for code; shading is nice;
\newenvironment{code}[1][]%
{%
\definecolor{shadecolor}{gray}{0.91}{#1}%
\topsep=0ex\relax
\shaded
\verbatim
}
{
\endverbatim
\endshaded
}

\maketitle

\newpage
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introducere}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

În ultimele doua decenii, programarea a fost în mare parte împărțită între două grupe de limbaje. Limbajele imperative, cu un sistem static de tipuri, multe dintre ele din familia C, au fost folosite pentru a obține performanță și scalabilitate. În schimb, flexibilitatea limbajelor precum Perl si PHP a fost apreciată pentru programarea scripturilor de sistem, a paginilor web și a altor programe pentru care eficiența nu reprezintă o prioritate.

În ultimii ani însă, odată cu reducerea exponențială a costurilor hardware-ului — mulțumită legii lui Moore — accentul a început să se pună din ce în ce mai puțin pe eficiență și din ce în ce mai mult pe timpul de dezvoltare. Performanța limbajelor dinamice a devenit „suficientă”, ceea ce a condus la o adevărată renaștere a acestora.

Atât Sun cât și Microsoft și-au arătat interesul pentru limbajele dinamice prin proiectele The Da Vinci Machine\cite{daVinciMachine} și Dynamic Language Runtime (DLR)\cite{dlr} și sprijinirea dezvoltării limbajelor JRuby\cite{jruby}, Jython\cite{jython}, IronRuby\cite{ironruby}, IronPython\cite{ironpython}, etc.

Lucrarea de față prezintă un limbaj dinamic numit Bonsai. Cea mai importantă caracteristică a sa este simplitatea, limbajele Lisp, Javascript și Io\cite{io} reprezentând principalele surse de inspirație.

Platforma aleasă este .NET Framework, împreună cu Dynamic Language Runtime. Întreaga suită de biblioteci .NET este astfel disponibilă, indiferent de limbajul in care au fost ele scrise. 

Bonsai este un limbaj funcțional\footnote{Datorită utilizării bibliotecilor .NET, transparența referențială a funcțiilor nu poate fi garantată. Bonsai nu este, așadar, un limbaj pur funcțional.}, dar se integrează bine cu alte limbaje orientate obiect. OOP-ul este simulat în întregime prin apeluri de funcții.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Parsarea și generarea arborilor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Primul modul din componența Bonsai se numește \c{Bonsai.Parser} și se ocupă de parsarea codului sursă și generarea arborilor de sintaxă abstractă.

\section{Scurtă descriere a ANTLR}

ANTLR 3\cite{antlr} este un instrument pentru construcția compilatoarelor și a translatoarelor care utilizează algoritmul de parsare \c{LL(*)} cu predicate\cite{definitive_antlr_reference}. Comparat cu ANTLR 2 (care bazat pe algoritmul \c{LL(k)}), numărul de gramatici ce pot fi parsate este cu mult îmbunătățit. Parserele generate sunt descendente-recursive, iar lista de limbaje suportate\cite{antlr_targets} include C, C\#, Java, Python și Javascript. 

În plus, spre deosebire de majoritatea generatoarelor de parser, ANTLR oferă în afară de suportul pentru scrierea de acțiuni asociate fiecărei reguli și opțiunea de a returna direct o instanță a unui arbore de parsare. Modul în care un nod este creat în urma aplicării unei reguli de gramatică poate fi controlat printr-o serie de operatori\cite{antlr_book_treeconstruction}.

Începând cu versiunea 3.1, ANTLR oferă și posibilitatea de a efectua transformări arbitrare și succesive asupra arborilor: spre exemplu, pornind de la arborele de parsare, mai multe gramatici de arbori (tree grammars) pot fi înlănțuite pentru a obține un arbore de sintaxă abstractă cât mai convenabil sau pentru aplicarea a diverse optimizări\cite{antlr_tree_grammars}\cite{antlr_book_treegrammars}.

Bonsai utilizează ANTLR 3.1 pentru parsarea codului sursă și pentru generarea AST-ului din arborele de parsare.

\section{Parsarea codului sursă}

Simplitatea limbajului se reflectă în dimensiunile gramaticii: aceasta are doar 18 reguli de parsare (inclusiv lexerul) și nici un cuvânt nu este rezervat\footnote{Gramatica de parsare este listată în întregime în Anexa \ref{app:grammar}}. În urma aplicării unei reguli rezultă un arbore de parsare, generat conform instrucțiunilor din gramatică. Acesta conține încă un număr ridicat de artefacte și nu poate fi considerat un arbore de sintaxă abstractă.

Din gramatică au fost generate cu ANTLR clasele \c{BonsaiParser} și \c{BonsaiLexer}. Următorul fragment oferă un exemplu de utilizare:

\begin{code}
var text = "... Bonsai code ...";
var strStream = new ANTLRStringStream(text);
var lexer = new BonsaiLexer(strStream);
var tokStream = new CommonTokenStream(lexer);
var parser = new Generated.BonsaiParser(tokStream);
var returnValue = parser.program();
\end{code}

Metoda \c{program} semnifică aplicarea regulei cu același nume. După rulare, \c{returnValue.Tree} va conține arborele de parsare.

\section{Generarea AST-ului}

Pe lângă gramatica de parsare, Bonsai utilizează și o gramatica de arbori, de doar 3 reguli\footnote{Gramatica de arbori este listată în întregime în Anexa \ref{app:tree_grammar}}, care transformă arborele de parsare într-un arbore de sintaxă abstractă. Clasa generată din aceastra gramatică este \c{BonsaiTree}.

Fragmentul următor este continuarea codului din secțiunea precedentă și demonstrează aplicarea gramaticii de arbori pe rezultatele parsării:

\begin{code}
var tree = (CommonTree)returnValue.Tree;
var treeNodeStream = 
    new CommonTreeNodeStream((CommonTree)returnValue.Tree);
var treeWalker = new Generated.BonsaiTree(treeNodeStream);
List<Call> statements = treeWalker.program().result.Statements;
\end{code}

După rulare, variabila \c{statements} va conține o listă de instanțe ale clasei \c{Call}. Este important de observat că rezultatul aplicării gramaticii de arbori reprezintă chiar instanțe de clase din namespace-ul \c{Bonsai.Ast}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introducere în DLR}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\draft{TODO: introductory text}

\section{CallSites}

Un \c{CallSite} reprezinta un context în care sunt rezolvate call-uri dinamice. Acesta poate fi asociat cu o singură linie de cod care conține un apel către o instanță a tipului \c{dynamic} din C\# 4.0\cite{csharp_4_specs} sau cu un întreg program scris într-un limbaj dynamic. 

Scopul principal al \c{CallSite}-urilor este de a mări performanța legaturilor dinamice prin păstrarea rezultatelor anterioare într-un cache. Când este nevoie de rezolvarea unui call, \c{CallSite}-ul caută mai întâi în cache un rezultat potrivit (prin testarea \c{BindingRestrictions}-urilor) și, dacă acesta este găsit, îl returnează imediat. Dacă nu (în cazul unui cache-miss), cererea este înaintată către un \c{Binder}.

\section{DynamicMetaObject, Binders și BindingRestrictions}

Un rezultat al rezolvării unui apel dinamic este reprezentat de o instanță a clasei \c{DynamicMetaObject}\cite{dynamic_meta_object}. Aceasta conține expresia LINQ\cite{linq_expressions} a apelului, tipul de date așteptat, valoarea la rulare a apelului (unde este cazul) și un set de \c{BindingRestrictions} care exprimă condițiile în care rezultatul este valid.

Un \c{Binder} este o clasă responsabilă cu rezolvarea unuia sau mai multe tipuri de expresii dinamice, cum ar fi apeluri de funcții, apeluri de membri, operatori infix, etc și returnarea unei instanțe de \c{DynamicMetaObject} ca rezultat. Bindereler sunt specifice unui anumit limbaj, rolul lor fiind de a ajuta la implementarea semanticii acestuia.

Pentru a rezolva apelurilor dinamice, un \c{Binder} trebuie să genereze o expresie LINQ asociată rezultatului și să returneze un \c{DynamicMetaObject} format din această expresie împreună cu un set de \c{BindingRestrictions}.

\section{Arbori de expresii}

Expresiile LINQ au fost introduse prima dată în versiunea 3.5 a .NET Framework\cite{expression_trees_35} și permit reprezentarea type-safe a anumitor "expresii" de cod managed, cum ar fi apelul unei metode sau o operație binară precum \c{a + 3}, într-un mod independent de limbaj. Expresiile sunt înstanțe de clase care moștenesc \c{System.Linq.Expressions.Expression}.

Fragmentul următor de cod oferă un scurt exemplu de utilizare, mai precis generarea și compilarea la runtime a unei expresii lambda care primește un parametru \c{a} de tip \c{int} și întoarce valoarea sa incrementată cu \c{1} (\c{a + 1}).
\begin{code}
// parametrul expresiei lambda declarate mai jos
var param = Expression.Parameter(typeof(int), "a");
var expr =
  Expression.Lambda<Func<int, int>>(
    // body-ul
    Expression.Add(
      param, //referintă la parametrul "a"
      Expression.Constant(1)),
    //lista de parametri
    new Expression[] { param });
// expresia LINQ se compilează într-un Func<int, int>
Func<int, int> func = expr.Compile();
Debug.Assert(10 == func(9));
\end{code}

Atât C\# 3.0 cât și VisualBasic 9.0 (versiunile din .NET 3.5) suportă definirea expresiilor LINQ într-un mod mult mai simplu. Toate expresiile asignate unei variabile de tipul \c{Expression<TDelegate>} sunt procesate de compilator și înlocuite cu instanțe de expresii lambda ce pot fi compilate sau analizate la runtime:
\begin{code}
Expression<Func<int, int>> expr2 = a => a + 1;
Func<int, int> func2 = expr2.Compile();
Debug.Assert(10 == func2(9));
\end{code}
În exemplul de mai sus, funcția \c{x => x + 1} este procesată de compilatorul C\# 3.0 iar variabilei \c{expr2} îi este asignată o expresie echivalentă celei din primul exemplu.

Expresiile LINQ pot fi de asemenea descompuse, analizate sau combinate cu alte expresii. Linq2Sql se folosește de această funcționalitate pentru a genera cod SQL plecând de la expresii C\# sau VB9.

\section{IDynamicMetaObjectProvider}

Pe lângă Bindere, DLR-ul oferă și posibilitatea ca un obiect să rezolve singur apelurile dinamice asupra lui, precum invocarea ca funcție sau apelul unui membru. Pentru aceasta, el trebuie să implementeze interfața \\ \c{IDynamicMetaObjectProvider}\cite{i_dynamic_meta_object_provider}. Binder-ele pot scurtcircuita acest mecanism și returna propriul rezultat, dar recomandat este ca rezolvarea unui apel către un obiect ce implementează \c{IDynamicMetaObjectProvider} să fie prelucrată de acesta, și nu de Binder.

Acest mecanism este deosebit de important pentru interoperabilitatea între limbaje dinamice diferite. De exemplu, un Binder din IronPython ar trebui să lase un obiect IronRuby să rezolve apelurile cu semantica proprie, de Ruby, și să nu încerce aplicarea semanticii Python. Astfel, toate obiectele cu semantică Ruby trebuie vor implementa interfața \c{IDynamicMetaObjectProvider}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Runtime-ul Bonsai}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Al doilea modul Bonsai, pe lângă \c{Bonsai.Parser}, este \c{Bonsai.Runtime}. Acesta include componente responsabile cu executia codului, implementarea semanticii Bonsai, integrarea cu CLR-ul și implementarea componentelor necesare din DLR.

\section{Generarea expresiilor LINQ}

Odată obținut AST-ul după parsare, următorul pas este transformarea acestuia în expresii LINQ\cite{linq_expressions}. 

Clasa răspunzătoare este \c{Bonsai.Runtime.Generator}. Aceasta conține câte o supraîncărcare a metodei \c{Walk} pentru fiecare tip de nod din arborele de sintaxă abstractă. Toate supraîncărcările au o definiție similară și întorc o expresie LINQ:
\begin{code}
public static class BonsaiExpressionGenerator {
  Expression Walk(Expression currentScopeVar, Call call);       
  Expression Walk(Expression currentScopeVar, Number number);
  Expression Walk(Expression currentScopeVar, String str);
  Expression Walk(Expression currentScopeVar, Symbol symbol);
  Expression Walk(Expression currentScopeVar, Block block);
  Expression Walk(Expression currentScopeVar, Reference reference);
  Expression Walk(Expression currentScopeVar, Sequence sequence);
  Expression Walk(Expression currentScopeVar, DataDecl decl);
}
\end{code}

\subsection{Tratarea scope-ului} 

În Bonsai, contextul de execuție curent este format din dicționarul variabilelor definite în contextul curent și o referință la contextul părinte. În momentul accesării unei variabile, ea este căutată mai întâi în dicționarul local, apoi în contextul părinte, recursiv.

Datorita semanticii blocurilor din Bonsai, ca în multe alte limbaje dinamice, contextul în care se execută un bloc nu poate fi cunoscut în momentul compilării. Soluția constă în tratarea acestuia ca pe o variabilă normală cu tipul \c{DictionaryBonsaiFunction}. 

Pentru ca expresiile LINQ generate să poată folosi contextul, toate supraîncărcările metodei \c{Generator.Walk} primesc ca prim parametru o expresie LINQ care reprezintă această variabilă.

De exemplu, mai jos este listată supraîncărcarea metodei \c{Walk} ce corespunde unui nod AST de tipul \c{Reference}. Nodurile \c{Reference} semnifică accesarea unei variabile din context după numele acesteia. 
\begin{code}
public static Expression Walk(
    Expression currentScopeVar,
    Ast.Reference reference)
{
    return Expression.MakeIndex(
        currentScopeVar,
        typeof(DictionaryBonsaiFunction).GetProperty("Item", 
            typeof(BonsaiFunction), new Type[] { typeof(SymbolId) }), 
        new Expression[] { Expression.Constant(
            SymbolTable.StringToId(reference.Name)) });
}
\end{code}
Primul parametru al metodei, \c{currentScopeVar}, este expresia menționată anterior, asociată variabilei în care e stocat contextul, iar expresia returnată reprezintă accesul printr-un indexer la aceasta. Codul C\# echivalent ar fi următorul:
\begin{code}
currentScope[someVariable]
\end{code}

\section{Clasa BonsaiBinder}

Deoarece totul în Bonsai este privit ca un apel de funcție, clasa \c{BonsaiBinder} implementează clasa abstractă \c{InvokeBinder}. Aceasta este o unealtă ajutătoare din DLR, potrivită cazurilor în care un implementator nu este interesat decât de apelurile dinamice ce reprezintă invocări de funcții. 

Singura metodă din \c{InvokeBinder} ce trebuie supraîncărcată este \c{FallbackInvoke}:
\begin{code}
public override DynamicMetaObject FallbackInvoke(
  DynamicMetaObject target,
  DynamicMetaObject[] args);
\end{code}
Primul parametru reprezintă obiectul apelat, iar al doilea un vector cu argumentele apelului.

Dacă \c{target} implementează interfața \c{IDynamicMetaObjectProvider}, \c{InvokeBinder} redirectează rezolvarea apelului către \c{target}. \c{FallbackInvoke} este apelat numai în cazul în care \c{target} nu poate rezolva apelul.

\c{BonsaiBinder.FallbackInvoke} testează dacă apelul întră într-una din următoarele categorii:
\begin{enumerate}
\item Apelarea unui \c{Delegate}
\item Referențierea unui obiect CLR
\item Apelarea unei primitive Bonsai
\item Invocarea unui membru al unui obiect CLR
\end{enumerate}

În caz contrar se consideră că binding-ul a eșuat și este aruncată o excepție.

\subsection{Apelarea unui Delegate}

Dacă tipul \c{target}-ului este o subclasă a \c{System.Delegate}, \c{BonsaiBinder} consideră acest apel dinamic ca fiind un apel static al unui delegate, iar Expresia generată va fi de tipul \c{InvocationExpression}.

\subsection{Referențierea obiectelor CLR}

Dacă \c{target} este un obiect CLR obișnuit non-dinamic și lista de argumente este vidă, binder-ul tratează apelul ca pe o "referențiere" și returnează expresia inițială (\c{target.Expression}). Altfel spus, un obiect obișnuit se evaluează la el însuși.

\subsection{Apelarea primitivelor și invocarea membrilor obiectelor CLR}

Atât în cazul primitivelor cât si al membrilor obiectelor CLR, apelul va fi rezolvat printr-un call al unei metode dintr-un tip CLR. În cazul primitivelor, o metodă din clasa în care acestea sunt definite, în cel al membrilor obiectelor CLR, din clasa obiectului \c{target}. Mai multe detalii vor fi prezentate în secțiunile ce urmează.

\section{Tratarea tipurilor de date primitive}

Primitivele în Bonsai pot fi considerate extensii ale anumitor tipuri, similar cu extension methods din C\# 3.0. De exemplu, primitiva \c{capitalize} este o extensie a tipului \c{string}, iar \c{shuffle} este o extensie a tipului \c{IList<T>}.

\draft{TODO: explain how primitives are defined and how they are resolved}

\section{Invocarea membrilor obiectelor CLR}

\draft{TODO: cum se determină metoda .NET corectă după tipurile argumentelor și numărul acestora.}

\section{Clasa BonsaiFunction}

\draft{TODO: Descrie ce anume face clasa BonsaiFunction și clasele derivate din aceasta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Biblioteca de funcții standard}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Spre deosebire de proiecte precum IronPython si IronRuby, care au fost nevoite sa implementeze întreaga biblioteca disponibilă în implementarile „originale” (MRI\cite{ruby_mri} si CPython\cite{cpython}), Bonsai încearcă să folosească cât mai mult clasele din .NET Framework și să mențină biblioteca proprie de funcții cât mai mică.

\section{Numere}

În Bonsai există un singur tip de numere: raționale, reprezentate in virgulă fixă. Acesta mapează peste tipul \texttt{System.Decimal} din .NET Framework. Erorile cauzate de reprezentarea in virgulă mobilă (ex. \texttt{1.1 + 1.1 + 1.1 == 3.300000000007}) sunt astfel eliminate.

\begin{tabular} { | r | l | }
  \hline
  symboluri & descriere \\
  \hline
  .\texttt{+, .-, .*, ./} & adunare, scădere, înmulțire, împărțire \\
  .\texttt{\textasciicircum} & ridicare la putere \\
  \draft{TODO} & \draft{Adaugă mai multe operații} \\
  \hline
\end{tabular}

\section{Șiruri de caractere}

Șirurile de caractere din Bonsai sunt instanțe ale clasei \texttt{System.String} din .NET.

\begin{tabular} { | r | l | }
  \hline
  symboluri & descriere \\
  \hline
  .\texttt{upcase} & Transformă toate caracterele în majuscule \\
  .\texttt{downcase} & Transformă toate caracterele în litere mici \\
  .\texttt{capitalize} & Transformă în majusculă prima literă din fiecare cuvânt \\
  .\texttt{contains} & Întoarce \texttt{true} dacă șirul conține subșirul căutat \\
  .\texttt{+} & Întoarce un nou șir obținut prin contactenarea strigului apelat cu argumentele \\
  .\texttt{} &  \\
  \hline
\end{tabular}

\section{Symboluri}

Tipul \texttt{symbol} din Bonsai este foarte asemănător simbolurilor din Ruby\cite{ruby_symbols} și Lisp\cite{clhs_symbols}. Un simbol se comportă de cele mai multe ori ca un string. Diferența majoră constă în faptul că pentru orice string există o singură instanță a unui simbol cu acel string, ceea ce face compararea a două simboluri foarte rapidă. De asemenea, utilizarea unui simbol indică de cele mai multe ori folosirea metaprogrămarii.

\section{Blocuri}

Un \texttt{block} este o secvență de instrucțiuni.

\draft{TODO}

\section{Funcții}

\draft{TODO}

\section{Pattern-Matching}

\subsection{Funcția \texttt{def|}}

\subsection{Șablonul \texttt{|=}}

\subsection{Șablonul \texttt{|is}}

\draft{TODO: definește mai multe șabloane}

\subsection{Definirea unui nou tip de șablon}

\section{Structuri de date}

Bonsai are o sintaxă specială pentru structuri de date.

\subsection{Liste și vectori}

\begin{code}
= .list [> 1 2 3 ]
= .array [| 1 2 3]
\end{code}

\subsection{Dictionare}

\begin{code}
= .dict [# 
  .a 1 
  .b 3
  .c 42 
]
\end{code}

\subsection{Definirea unui nou tip de structuri de date}

\draft{TODO}

\section{Alte funcții}

Aceste funcții sunt disponibile în biblioteca standard, dar nu au putut fi incluse în nici una din categoriile de mai sus.

\subsection{Funcția \c{ref}}

\draft{TODO}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Bonsai și Programarea Orientată Obiect}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Spre deosebire de limbajele Io\cite{io} și SmallTalk\cite{smalltalk}, unde orice este un obiect, în Bonsai orice este o funcție. Mai mult, dacă în SmallTalk și Io orice expresie reprezintă trimiterea unui mesaj către un obiect, iar rezultatul tot un obiect, în Bonsai orice expresie este un apel de funcție, iar rezultatul tot o funcție.

Această diferență poate părea fundamentală, dar o funcție poate fi considerată generalizarea unui obiect. În secțiunile următoare vom vedea cum toate cele trei principii fundamentale OOP – moștenirea, encapsularea și polimorfismul – sunt „simulate” în Bonsai cu ajutorul funcțiilor.

\section{Paralela funcțional <-> OOP}

Baza programarii orientate obiect o reprezinta message-passing-ul. Acesta este emulat în Bonsai printr-un apel de funcție în care primul parametru este un simbol. Funcția reprezintă obiectul, iar simbolul, mesajul trimis. Spre exemplu, un string apelat cu simbolul \texttt{:upcase} va returna un nou string cu toate caracterele transformate în majuscule:
\begin{code}
"bonsai!" .upcase
\end{code}
Acest cod Bonsai are același efect cu următorul cod C\#:
\begin{code}
"bonsai".ToUpper()
\end{code}
În cazul în care mesajul are mai mulți parametri, aceștia urmează după simbol:
\begin{code}
stringBuilder .Append " ultima parte "
\end{code}

Moștenirea poate fi simulată printr-o funcție care este definită doar pentru un set de pattern-uri peste parametri, apelurile cu alți parametri fiind redirectate către o alta funcție (analogul clasei de bază).

Tratarea mesajelor în acest fel poate părea primitivă și greoaie, dar în practică nu se face niciodată o tratare manuală (de tip \texttt{case}): toate operațiile OOP „clasice” sunt abstractizate printr-un set de funcțtii incluse în biblioteca standard a limbajului.

\section{Crearea prototipurilor}

\draft{TODO}

\section{Clonarea instanțelor noi din prototipuri}

\draft{Metoda \texttt{clone}}

\section{Encapsularea}

\draft{TODO: convenția \texttt{\_}, similar Python}

\section{Polimormism?}

\draft{Limbaj dinamic = polimorfism implicit (?)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Integrarea cu platforma .NET}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Unul din principale avantajele în utilizarea runtime-ului .NET este posibilitatea de a folosi bibliotecile disponibile, atât oficiale cât și particulare. Bonsai dispune de un set de primitive care fac acest lucru posibil.

\section{primitiva \texttt{import}}

Primitiva \texttt{import}

\section{Spații de nume și clase statice}

\section{Instanțierea obiectelor}

\section{Pasarea funcțiilor Bonsai către metode .NET}

\section{Integrarea cu alte limbaje dinamice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Posibile îmbunătățiri}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Module}

\section{Spații de nume}

\section{Metaprogramare}

\draft{inspectarea codului sursă al funcțiilor la rulare; modificarea și recompilarea acestuia}

\draft{similar, modificarea și recompilarea AST-ului la rulare}

\draft{posibilitatea evaluării non-stricte a argumentelor (à la Haskell); avantaje/dezavantaje}

\section{Debugger}

\draft{posibilități de realizare a unui debugger; integrarea cu VisualStudio?}

\section{Îmbunătățirea performanței}

\section{Tratarea excepțiilor}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{appendices}

\fvset{numbers=left,labelposition=all,frame=lines}

\chapter{Gramatica limbajului Bonsai}
\label{app:grammar}
\VerbatimInput[label=Bonsai.g]{../src/Grammars/Bonsai.g}

\chapter{Gramatica de arbori}
\label{app:tree_grammar}
\VerbatimInput[label=BonsaiTree.g]{../src/Grammars/BonsaiTree.g}

\end{appendices}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{unsrt}
\bibliography{bonsai}{}

\end{document}
